param(
  [switch]$SelfTest,
  [switch]$KeepArtifacts,
  [int]$WindowSeconds = 6,

  # Weak-only triggers require repeats (to avoid false positives)
  [int]$WeakRepeatThreshold = 2,
  [int]$WeakRepeatWindowSeconds = 30
)

$ErrorActionPreference="SilentlyContinue"

# GuardianFW Detect-DoH (ETW via netsh)
# Exit: 0 = clean, 20 = suspicious (DoH-resolver IP seen on TCP 443)

$dohIps = @("1.1.1.1","1.0.0.1","8.8.8.8","8.8.4.4","9.9.9.9","149.112.112.112")

$eventsDir = "C:\ProgramData\GuardianFW\events"
New-Item -ItemType Directory -Path $eventsDir -Force | Out-Null
$logPath = Join-Path $eventsDir "doh-detect.jsonl"

# state cache for weak-repeat logic
$statePath = Join-Path $eventsDir "doh-detect.state.json"

$etl = Join-Path $eventsDir "tcpip_doh.etl"
$txt = Join-Path $eventsDir "tcpip_doh.txt"

function Stop-TraceQuiet { try { netsh trace stop | Out-Null } catch {} }

function Load-State {
  if(Test-Path $statePath){
    try { return (Get-Content -LiteralPath $statePath -Raw -EA SilentlyContinue | ConvertFrom-Json) } catch {}
  }
  return [pscustomobject]@{ weak_hits = @() }
}

function Save-State($state){
  try { $state | ConvertTo-Json -Compress | Set-Content -LiteralPath $statePath -Encoding UTF8 -Force } catch {}
}

function Add-EventLog($obj){
  try { ($obj | ConvertTo-Json -Compress) | Add-Content -LiteralPath $logPath -Encoding UTF8 } catch {}
}

function Proc-Name([int]$pid){
  if($pid -le 0){ return "unknown" }
  try { $p = Get-Process -Id $pid -EA SilentlyContinue; if($p){ return $p.ProcessName } } catch {}
  return "unknown"
}

# Ensure no prior trace is running
Stop-TraceQuiet

# Clean artifacts before run
try { Remove-Item $etl,$txt -Force -EA SilentlyContinue | Out-Null } catch {}

try {
  # Start ETW trace
  netsh trace start capture=no report=no tracefile="$etl" provider=Microsoft-Windows-TCPIP level=5 keywords=0xFFFFFFFF | Out-Null

  # Optional self-test INSIDE capture window
  if($SelfTest){
    Start-Sleep -Milliseconds 200
    $u="https://cloudflare-dns.com/dns-query?name=example.com&type=A"
    curl.exe -s --http1.1 "$u" --resolve cloudflare-dns.com:443:1.1.1.1 -H "accept: application/dns-json" | Out-Null
  }

  Start-Sleep -Seconds $WindowSeconds
}
finally {
  Stop-TraceQuiet
}

# Convert trace
netsh trace convert input="$etl" output="$txt" | Out-Null

# Read RAW so regex survives wrapping/newlines
$blob = ""
try { $blob = Get-Content -LiteralPath $txt -Raw -EA SilentlyContinue } catch {}

if(-not $blob){
  if(-not $KeepArtifacts){ try { Remove-Item $etl,$txt -Force -EA SilentlyContinue | Out-Null } catch {} }
  exit 0
}

$hits = @()

# STRONG: "... remote=IP:443) ... connect completed. PID = N"
$reStrong = [regex]'(?is)(?:remote|Remote)\s*=\s*(\d{1,3}(?:\.\d{1,3}){3}):443\)\s*connect\s+completed\.\s*PID\s*=\s*(\d+)'
foreach($m in $reStrong.Matches($blob)){
  $rip = $m.Groups[1].Value
  if($dohIps -notcontains $rip){ continue }
  $pid = [int]$m.Groups[2].Value

  $hits += [pscustomobject]@{
    ts       = (Get-Date).ToString("s")
    remote   = $rip
    port     = 443
    pid      = $pid
    proc     = (Proc-Name $pid)
    strength = "strong"
    source   = "etw_tcpip_connect_completed"
  }
}

# MEDIUM: requested/proceeding patterns (PID usually present)
# Examples seen on some machines:
#   "... requested to connect."
#   "... connect proceeding."
# NOTE: netsh formatting varies; keep regex tolerant.
$reMedium = [regex]'(?is)(?:remote|Remote)\s*=\s*(\d{1,3}(?:\.\d{1,3}){3}):443\).*?\b(requested\s+to\s+connect|connect\s+proceeding)\b.*?\bPID\s*=\s*(\d+)'
foreach($m in $reMedium.Matches($blob)){
  $rip = $m.Groups[1].Value
  if($dohIps -notcontains $rip){ continue }

  # Avoid duplicates if we already have strong for same remote+pid
  $pid = [int]$m.Groups[3].Value
  if($hits | Where-Object { $_.remote -eq $rip -and $_.pid -eq $pid -and $_.strength -eq "strong" }){ continue }

  $hits += [pscustomobject]@{
    ts       = (Get-Date).ToString("s")
    remote   = $rip
    port     = 443
    pid      = $pid
    proc     = (Proc-Name $pid)
    strength = "medium"
    source   = "etw_tcpip_preconnect"
  }
}

# WEAK: "... remote=IP:443) exists. State = ... PID = N" (often PID=0)
$reWeak = [regex]'(?is)(?:remote|Remote)\s*=\s*(\d{1,3}(?:\.\d{1,3}){3}):443\)\s*exists\.\s*State\s*=\s*\d+\([^)]+\),\s*PID\s*=\s*(\d+)'
$weakSeen = @()
foreach($m in $reWeak.Matches($blob)){
  $rip = $m.Groups[1].Value
  if($dohIps -notcontains $rip){ continue }

  # if strong/medium already exists for this remote, weak adds no value
  if($hits | Where-Object { $_.remote -eq $rip -and $_.strength -in @("strong","medium") }){ continue }

  $pid = [int]$m.Groups[2].Value
  $weakSeen += $rip

  $hits += [pscustomobject]@{
    ts       = (Get-Date).ToString("s")
    remote   = $rip
    port     = 443
    pid      = $pid
    proc     = (Proc-Name $pid)
    strength = "weak"
    source   = "etw_tcpip_exists_state"
  }
}

# Cleanup artifacts unless asked to keep
if(-not $KeepArtifacts){
  try { Remove-Item $etl,$txt -Force -EA SilentlyContinue | Out-Null } catch {}
}

# --- Decision Logic ---
# strong/medium => immediate suspicious
if($hits | Where-Object { $_.strength -in @("strong","medium") }){
  foreach($h in $hits){ Add-EventLog $h }
  exit 20
}

# weak-only => require repeats within window
if($hits.Count -gt 0){
  $state = Load-State

  $now = Get-Date
  # keep only recent timestamps
  $cut = $now.AddSeconds(-1 * $WeakRepeatWindowSeconds)

  $recent = @()
  foreach($w in $state.weak_hits){
    try {
      $dt = [datetime]$w.ts
      if($dt -ge $cut){ $recent += $w }
    } catch {}
  }

  foreach($rip in ($weakSeen | Select-Object -Unique)){
    $recent += [pscustomobject]@{ ts = $now.ToString("o"); remote = $rip }
  }

  $state.weak_hits = $recent
  Save-State $state

  # count repeats per remote
  foreach($rip in ($weakSeen | Select-Object -Unique)){
    $count = @($state.weak_hits | Where-Object { $_.remote -eq $rip }).Count
    if($count -ge $WeakRepeatThreshold){
      foreach($h in $hits){ Add-EventLog $h }
      exit 20
    }
  }

  # weak seen but not enough repeats -> log as weak event but exit clean (optional)
  foreach($h in $hits){ Add-EventLog $h }
  exit 0
}

exit 0
