# --- Single-instance guard (mutex) ---
$mutexName = "Global\GuardianFW-ProcessDNS"
$mutex = New-Object System.Threading.Mutex($false, $mutexName)
$hasLock = $false
try {
  $hasLock = $mutex.WaitOne(0)
  if(-not $hasLock){ exit 0 }

Set-StrictMode -Version Latest
$ErrorActionPreference="Stop"

$Root="C:\ProgramData\GuardianFW"
$Policy=Join-Path $Root "policy\policy.json"
$DohIps=Join-Path $Root "policy\doh-ips.json"
$Audit=Join-Path $Root "logs\guardian-audit.jsonl"
$Fail =Join-Path $Root "sealed\FAIL_SECURE.flag"

function Write-Audit([string]$event,[hashtable]$data=@{}) {
  $dir = Split-Path $Audit
  if(!(Test-Path $dir)){ New-Item -ItemType Directory -Path $dir -Force | Out-Null }

  # ---- Rate limit noisy duplicate decision events ----
  # Only rate-limit when we can build a stable key (process/domain/decision/etc).
  $stateDir  = Join-Path $Root "state"
  $stateFile = Join-Path $stateDir "audit-rate.json"
  if(!(Test-Path $stateDir)){ New-Item -ItemType Directory -Path $stateDir -Force | Out-Null }

  function Get-AuditKey([string]$ev,[hashtable]$d){
    if($null -eq $d){ return $null }

    $p  = $null; $dom=$null; $dec=$null; $dst=$null; $proto=$null

    if($d.ContainsKey("process"))  { $p    = [string]$d["process"] }
    if($d.ContainsKey("domain"))   { $dom  = [string]$d["domain"] }
    if($d.ContainsKey("decision")) { $dec  = [string]$d["decision"] }
    if($d.ContainsKey("dst"))      { $dst  = [string]$d["dst"] }
    if($d.ContainsKey("proto"))    { $proto= [string]$d["proto"] }

    # Require at least process+domain+decision to rate-limit (prevents hiding important system events)
    if([string]::IsNullOrWhiteSpace($p) -or [string]::IsNullOrWhiteSpace($dom) -or [string]::IsNullOrWhiteSpace($dec)){
      return $null
    }

    # Keep key compact + stable
    return ("{0}|{1}|{2}|{3}|{4}|{5}" -f $ev,$p.ToLowerInvariant(),$dom.ToLowerInvariant(),$dec.ToLowerInvariant(),$dst,$proto)
  }

  $key = Get-AuditKey $event $data
  $minGapSec = 300  # 5 minutes
  $now = [DateTime]::UtcNow

  $state = @{}
  if(Test-Path $stateFile){
    try {
      $obj = Get-Content $stateFile -Raw -Encoding UTF8 | ConvertFrom-Json
      if($obj){
        foreach($prop in $obj.PSObject.Properties){
          $state[$prop.Name] = [string]$prop.Value
        }
      }
    } catch { $state = @{} }
  }

  # Prune old keys (> 2 days) so file doesn't grow forever
  foreach($k in @($state.Keys)){
    try {
      $t = [DateTime]::Parse($state[$k]).ToUniversalTime()
      if(($now - $t).TotalDays -gt 2){ $state.Remove($k) }
    } catch { $state.Remove($k) }
  }

  if($null -ne $key -and $state.ContainsKey($key)){
    $last = $null
    try { $last = [DateTime]::Parse($state[$key]).ToUniversalTime() } catch { $last = $null }
    if($null -ne $last -and ($now - $last).TotalSeconds -lt $minGapSec){
      return  # suppress noisy duplicate
    }
  }

  # Write audit record
  $rec=[pscustomobject]@{
    tsUtc = (Get-Date).ToUniversalTime().ToString("o")
    event = $event
    data  = $data
  }
  ($rec|ConvertTo-Json -Compress -Depth 12) | Add-Content -LiteralPath $Audit -Encoding UTF8

  # Update state only when we used a key (decision events)
  if($null -ne $key){
    $state[$key] = $now.ToString("o")
    try {
      ($state | ConvertTo-Json -Depth 6) | Set-Content -LiteralPath $stateFile -Encoding UTF8
    } catch {
      # If state can't be saved, don't break enforcement
    }
  }
}

function HasProp($o,[string]$n){ return ($o -and $o.PSObject.Properties.Match($n).Count -gt 0) }

function Safe-LoadJson([string]$path){
  try { return (Get-Content -LiteralPath $path -Raw -Encoding UTF8 | ConvertFrom-Json) }
  catch { Write-Audit "json_load_failed" @{path=$path; error=$_.Exception.Message}; return $null }
}

# -------------------------
# Load policy
# -------------------------
$cfg = Safe-LoadJson $Policy
if($null -eq $cfg){ exit 0 }

if(-not (HasProp $cfg "process_dns_policy")){
  Write-Audit "process_dns_policy_missing" @{}
  exit 0
}

$pdp = $cfg.process_dns_policy
$mode="monitor"; $action="log"
if(HasProp $pdp "mode"){ $mode=[string]$pdp.mode }
if(HasProp $pdp "action"){ $action=[string]$pdp.action }

$rules=@()
if(HasProp $pdp "allow" -and $pdp.allow){ $rules=@($pdp.allow) }

function Is-AllowedImage([string]$img){
  foreach($r in $rules){
    if($r -and (HasProp $r "image") -and $r.image){
      if($img -ieq [string]$r.image){ return $true }
    }
  }
  return $false
}

# -------------------------
# Load DoH IP list (optional)
# -------------------------
$dohSet = @{}
$doh = Safe-LoadJson $DohIps
if($doh -and (HasProp $doh "providers") -and $doh.providers){
  foreach($prov in @($doh.providers)){
    if($prov -and (HasProp $prov "ips") -and $prov.ips){
      $pname = $null
      if(HasProp $prov "name"){ $pname = [string]$prov.name }
      foreach($ip in @($prov.ips)){
        if($ip){ $dohSet[[string]$ip] = $pname }
      }
    }
  }
}

# -------------------------
# DNS53 detection:
# - UDP: LocalPort == 53
# - TCP: RemotePort == 53
# -------------------------
$udp = Get-NetUDPEndpoint -ErrorAction SilentlyContinue | Where-Object { $_.LocalPort -eq 53 }
foreach($u in $udp){
  $ProcId=[int]$u.OwningProcess
  if($ProcId -le 4){ continue }

  $p = Get-Process -Id $ProcId -ErrorAction SilentlyContinue
  if(!$p -or -not $p.Path){ continue }
  $img=[string]$p.Path

  if(-not (Is-AllowedImage $img)){
    Write-Audit "process_dns_violation" @{
      kind="dns53_udp"; pid=$ProcId; image=$img;
      local=$u.LocalAddress; lport=$u.LocalPort;
      mode=$mode; action=$action
    }

    if($mode -ieq "enforce" -and $action -ieq "kill"){
      try { Stop-Process -Id $ProcId -Force; Write-Audit "process_dns_killed" @{kind="dns53_udp"; pid=$ProcId; image=$img} }
      catch { Write-Audit "process_dns_kill_failed" @{kind="dns53_udp"; pid=$ProcId; image=$img; error=$_.Exception.Message}; New-Item -ItemType File -Path $Fail -Force | Out-Null }
    }
  }
}

$tcp53 = Get-NetTCPConnection -State Established -ErrorAction SilentlyContinue | Where-Object { $_.RemotePort -eq 53 }
foreach($c in $tcp53){
  $ProcId=[int]$c.OwningProcess
  if($ProcId -le 4){ continue }

  $p = Get-Process -Id $ProcId -ErrorAction SilentlyContinue
  if(!$p -or -not $p.Path){ continue }
  $img=[string]$p.Path

  if(-not (Is-AllowedImage $img)){
    Write-Audit "process_dns_violation" @{
      kind="dns53_tcp"; pid=$ProcId; image=$img; remote=$c.RemoteAddress; port=$c.RemotePort;
      mode=$mode; action=$action
    }

    if($mode -ieq "enforce" -and $action -ieq "kill"){
      try { Stop-Process -Id $ProcId -Force; Write-Audit "process_dns_killed" @{kind="dns53_tcp"; pid=$ProcId; image=$img} }
      catch { Write-Audit "process_dns_kill_failed" @{kind="dns53_tcp"; pid=$ProcId; image=$img; error=$_.Exception.Message}; New-Item -ItemType File -Path $Fail -Force | Out-Null }
    }
  }
}

# -------------------------
# DoH IP correlation (SAFE):
# - TCP 443 only if RemoteAddress is in doh-ips.json
# - Include short-lived states to increase capture chance
# -------------------------
if($dohSet.Count -gt 0){
  $tcp443 = Get-NetTCPConnection -ErrorAction SilentlyContinue |
            Where-Object { $_.RemotePort -eq 443 -and $_.State -in @("Established","SynSent","TimeWait") }

  foreach($c in $tcp443){
    $rip = [string]$c.RemoteAddress
    if(-not $rip){ continue }
    if(-not $dohSet.ContainsKey($rip)){ continue }

    $ProcId=[int]$c.OwningProcess
    if($ProcId -le 4){ continue }

    $p = Get-Process -Id $ProcId -ErrorAction SilentlyContinue
    $img = $null
    if($p -and $p.Path){ $img = [string]$p.Path }

    $provider = $dohSet[$rip]

    Write-Audit "process_dns_violation" @{
      kind="doh_ip_hit"; pid=$ProcId; image=$img; remote=$rip; port=443; provider=$provider;
      mode=$mode; action=$action
    }

    if($Host.Name -match "ConsoleHost"){
      Write-Host ("DoH hit: {0} {1} {2}" -f $provider, $rip, $img)
    }

    if($mode -ieq "enforce" -and $action -ieq "kill"){
      try { Stop-Process -Id $ProcId -Force; Write-Audit "process_dns_killed" @{kind="doh_ip_hit"; pid=$ProcId; image=$img; remote=$rip; provider=$provider} }
      catch { Write-Audit "process_dns_kill_failed" @{kind="doh_ip_hit"; pid=$ProcId; image=$img; remote=$rip; provider=$provider; error=$_.Exception.Message}; New-Item -ItemType File -Path $Fail -Force | Out-Null }
    }
  }
}

# -------------------------
# DEBUG: observe 443 remotes (always)
# -------------------------
try {
  $tcp443all = Get-NetTCPConnection -State Established -ErrorAction SilentlyContinue | Where-Object { $_.RemotePort -eq 443 }
  foreach($c in $tcp443all){
    $ProcId=[int]$c.OwningProcess
    if($ProcId -le 4){ continue }

    $p = Get-Process -Id $ProcId -ErrorAction SilentlyContinue
    $img=$null
    if($p -and $p.Path){ $img=[string]$p.Path }

    $rip=[string]$c.RemoteAddress
    if(-not $rip){ continue }

    $prov=$null
    if($dohSet.Count -gt 0 -and $dohSet.ContainsKey($rip)){ $prov=$dohSet[$rip] }

    Write-Audit "tcp443_seen" @{ pid=$ProcId; image=$img; remote=$rip; provider=$prov }
  }
} catch {
  Write-Audit "tcp443_seen_failed" @{ error=$_.Exception.Message }
}

# Optional pause when manual:
#   setx GUARDIANFW_PAUSE 1
if($Host.Name -match "ConsoleHost" -and $env:GUARDIANFW_PAUSE -eq "1"){
  Read-Host "Press Enter" | Out-Null
}

exit 0

} finally {
  if($hasLock){ $mutex.ReleaseMutex() | Out-Null }
  $mutex.Dispose()
}


