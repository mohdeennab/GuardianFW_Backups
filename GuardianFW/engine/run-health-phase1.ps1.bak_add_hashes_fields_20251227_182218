# run-health-phase1.ps1
# Phase 1 deterministic wrapper + mutex + DNS enforcement + DNS drift (single evidence line)

$ErrorActionPreference="Stop"
Set-StrictMode -Version Latest

Import-Module "C:\ProgramData\GuardianFW\engine\Guardian.ExitCodes.psm1" -Force
Import-Module "C:\ProgramData\GuardianFW\engine\Guardian.Evidence.psm1" -Force
Import-Module "C:\ProgramData\GuardianFW\engine\Guardian.Config.psm1" -Force
Import-Module "C:\ProgramData\GuardianFW\engine\Guardian.DB.psm1" -Force
Import-Module "C:\ProgramData\GuardianFW\engine\Guardian.Map.psm1" -Force

# ---- Mutex: prevent overlapping runs (Local works for Admin + SYSTEM) ----
$mutexName = "Local\GuardianFW_Health_Lock"
$mutex = $null
$hasLock = $false

$cor   = ""
$start = Get-Date


# policy mode (safe read)
$policyMode = "enforce"
try {
  $pp = "C:\ProgramData\GuardianFW\policy\dns-policy.json"
  if(Test-Path $pp){
    $po = (Get-Content -LiteralPath $pp -Raw -Encoding UTF8) | ConvertFrom-Json
    if($po.mode){ $policyMode = ([string]$po.mode).ToLower() }
  }
} catch { $policyMode = "enforce" }

try {
  # Create mutex (best-effort)
  try {
    $mutex = New-Object System.Threading.Mutex($false, $mutexName)
  } catch {
    $mutex = $null
  }

  # Acquire lock (or proceed without mutex)
  if($null -ne $mutex){
    $hasLock = $mutex.WaitOne(5000)
  } else {
    $hasLock = $true
  }

  if(-not $hasLock){
    exit $EXIT_NOOP
  }

  # ---- DNS enforcement (fold into details; no extra evidence) ----
  $dns = @{ status="NOT_RUN" }
  try {
    . "C:\ProgramData\GuardianFW\engine\Enforce-DnsPolicy.ps1"
    $r = Apply-GfwDnsPolicy
$dnsPolicyVersion = $null
try {
  $p = "C:\ProgramData\GuardianFW\policy\dns-policy.json"
  if(Test-Path $p){
    $po = (Get-Content -LiteralPath $p -Raw -Encoding UTF8) | ConvertFrom-Json
    $dnsPolicyVersion = $po.version
  }
} catch { $dnsPolicyVersion = $null }
$dnsPolicyVersion = $null
try {
  $p = "C:\ProgramData\GuardianFW\policy\dns-policy.json"
  if(Test-Path $p){
    $po = (Get-Content -LiteralPath $p -Raw -Encoding UTF8) | ConvertFrom-Json
    $dnsPolicyVersion = $po.version
  }
} catch { $dnsPolicyVersion = $null }
    if($r -is [hashtable]){ $dns = $r } else { $dns = @{ status="BAD_RETURN_TYPE" } }
  } catch {
    $dns = @{ status="FAIL"; error=$_.Exception.Message }
  }
# ---- DNS drift (PRE/POST; fold into details; no extra evidence) ----
$drift_pre  = @{ drift=$false; reason="NOT_RUN" }
$drift_post = @{ drift=$false; reason="NOT_RUN" }
$dns_repaired = $false

try {
  if(Get-Command Check-GfwDnsDrift -ErrorAction SilentlyContinue){
    $dpre = Check-GfwDnsDrift
    if($dpre -is [hashtable]){ $drift_pre = $dpre } else { $drift_pre = @{ drift=$false; reason="BAD_RETURN_TYPE_PRE" } }
  } else {
    $drift_pre = @{ drift=$false; reason="NO_FUNCTION" }
  }
} catch {
  $drift_pre = @{ drift=$false; reason="DRIFT_PRE_FAIL"; error=# run-health-phase1.ps1
# Phase 1 deterministic wrapper + mutex + DNS enforcement + DNS drift (single evidence line)

$ErrorActionPreference="Stop"
Set-StrictMode -Version Latest

Import-Module "C:\ProgramData\GuardianFW\engine\Guardian.ExitCodes.psm1" -Force
Import-Module "C:\ProgramData\GuardianFW\engine\Guardian.Evidence.psm1" -Force
Import-Module "C:\ProgramData\GuardianFW\engine\Guardian.Config.psm1" -Force
Import-Module "C:\ProgramData\GuardianFW\engine\Guardian.DB.psm1" -Force
Import-Module "C:\ProgramData\GuardianFW\engine\Guardian.Map.psm1" -Force

# ---- Mutex: prevent overlapping runs (Local works for Admin + SYSTEM) ----
$mutexName = "Local\GuardianFW_Health_Lock"
$mutex = $null
$hasLock = $false

$cor   = ""
$start = Get-Date


# policy mode (safe read)
$policyMode = "enforce"
try {
  $pp = "C:\ProgramData\GuardianFW\policy\dns-policy.json"
  if(Test-Path $pp){
    $po = (Get-Content -LiteralPath $pp -Raw -Encoding UTF8) | ConvertFrom-Json
    if($po.mode){ $policyMode = ([string]$po.mode).ToLower() }
  }
} catch { $policyMode = "enforce" }

try {
  # Create mutex (best-effort)
  try {
    $mutex = New-Object System.Threading.Mutex($false, $mutexName)
  } catch {
    $mutex = $null
  }

  # Acquire lock (or proceed without mutex)
  if($null -ne $mutex){
    $hasLock = $mutex.WaitOne(5000)
  } else {
    $hasLock = $true
  }

  if(-not $hasLock){
    exit $EXIT_NOOP
  }

  # ---- DNS enforcement (fold into details; no extra evidence) ----
  $dns = @{ status="NOT_RUN" }
  try {
    . "C:\ProgramData\GuardianFW\engine\Enforce-DnsPolicy.ps1"
    $r = Apply-GfwDnsPolicy
$dnsPolicyVersion = $null
try {
  $p = "C:\ProgramData\GuardianFW\policy\dns-policy.json"
  if(Test-Path $p){
    $po = (Get-Content -LiteralPath $p -Raw -Encoding UTF8) | ConvertFrom-Json
    $dnsPolicyVersion = $po.version
  }
} catch { $dnsPolicyVersion = $null }
$dnsPolicyVersion = $null
try {
  $p = "C:\ProgramData\GuardianFW\policy\dns-policy.json"
  if(Test-Path $p){
    $po = (Get-Content -LiteralPath $p -Raw -Encoding UTF8) | ConvertFrom-Json
    $dnsPolicyVersion = $po.version
  }
} catch { $dnsPolicyVersion = $null }
    if($r -is [hashtable]){ $dns = $r } else { $dns = @{ status="BAD_RETURN_TYPE" } }
  } catch {
    $dns = @{ status="FAIL"; error=$_.Exception.Message }
  }

  # ---- DNS drift (fold into details; no extra evidence) ----
  $drift = @{ drift=$false; reason="NOT_RUN" }
  try {
    . "C:\ProgramData\GuardianFW\engine\Check-DnsDrift.ps1"
    if(Get-Command Check-GfwDnsDrift -ErrorAction SilentlyContinue){
      $d = Check-GfwDnsDrift
      if($d -is [hashtable]){ $drift = $d } else { $drift = @{ drift=$false; reason="BAD_RETURN_TYPE" } }
    } else {
      $drift = @{ drift=$false; reason="NO_FUNCTION" }
    }
  } catch {
    $drift = @{ drift=$false; reason="DRIFT_CHECK_FAIL"; error=$_.Exception.Message }
  }

  # If drift detected, re-apply once (best-effort) so the system self-heals
$dns_repaired = $false
if($policyMode -eq "enforce" -and $drift -is [hashtable] -and $drift.drift -eq $true){
  try {
    $r2 = Apply-GfwDnsPolicy
    if($r2 -is [hashtable]){ $dns = $r2 }
    $dns_repaired = $true
  } catch { }
}
# 1) Baseline integrity
  $b = Test-GfwBaseline
  if(-not $b.ok){
    $cor = Write-GfwEvidence `
      -Component "health" `
      -Action "verify_baseline" `
      -Result "TAMPER" `
      -ExitCode $EXIT_TAMPER `
      -Details $b `
      -CorrelationId $cor
    exit $EXIT_TAMPER
  }

  # 2) Optional DB init (no evidence here)
  $sqlite = "C:\ProgramData\GuardianFW\tools\sqlite3.exe"
  $sqlite_status = "missing"
  $sqlite_error  = ""
  if(Test-Path $sqlite){
    $sqlite_status = "present"
    try { Initialize-GfwDb } catch { $sqlite_error = $_.Exception.Message }
  }

  # 3) Call inner health
  $inner = "C:\ProgramData\GuardianFW\engine\run-health.ps1"
  & powershell.exe -NoProfile -ExecutionPolicy Bypass -File $inner
  $code = $LASTEXITCODE

  # 4) Canonicalize + single evidence
  $elapsedMs = [int]((Get-Date) - $start).TotalMilliseconds
  $canon = Convert-GfwInnerExitToCanonical -InnerExit $code
# ---- FINAL normalize of dns_repaired (must match drift_pre/drift_post truth) ----
$preDrift  = $false
$postDrift = $false
try { if($drift_pre  -is [hashtable] -and $drift_pre.ContainsKey("drift"))  { $preDrift  = [bool]$drift_pre.drift } } catch {}
try { if($drift_post -is [hashtable] -and $drift_post.ContainsKey("drift")) { $postDrift = [bool]$drift_post.drift } } catch {}
$dns_repaired = ($policyMode -eq "enforce" -and $preDrift -eq $true -and $postDrift -eq $false)

  $details = @{
    inner_exit         = $code
    canonical          = $canon.result
    canonical_exit     = [int]$canon.exit_code
    elapsed_ms         = $elapsedMs
    sqlite             = $sqlite_status

    dns_status         = $dns.status
    dns_drift          = $drift_post.drift
    dns_drift_reason   = $drift_post.reason
    dns_repaired      = [bool]$dns_repaired
    dns_would_change  = ($(if($dns -is [hashtable] -and $dns.ContainsKey("would_change")){ [bool]$dns.would_change } else { $false }))
    dns_repaired      = [bool]$dns_repaired
    dns_would_change  = ($(if($dns -is [hashtable] -and $dns.ContainsKey("would_change")){ [bool]$dns.would_change } else { $false }))
  }

  if($dns -is [hashtable]){
    if($dns.ContainsKey("count")) {  $details.dns_count  = $dns.count }
    if($dns.ContainsKey("hosts")) {  $details.dns_hosts  = $dns.hosts }
    if($dns.ContainsKey("policy")){  $details.dns_policy = $dns.policy }
    if($null -ne $dnsPolicyVersion){ $details.dns_policy_version = [int]$dnsPolicyVersion }
    if($dns.ContainsKey("error")){  $details.dns_error  = $dns.error }
    if($dns.ContainsKey("would_change")){ $details.dns_would_change = [bool]$dns.would_change }
  }

  if($drift_post -is [hashtable]){
    if($drift_post.ContainsKey("prev")){  $details.dns_prev_hash = $drift_post.prev }
    if($drift_post.ContainsKey("hash")){  $details.dns_hash      = $drift_post.hash }
    if($drift_post.ContainsKey("error")){ $details.dns_drift_error = $drift_post.error }
    if($drift_post.ContainsKey("expected_hash")){ $details.dns_expected_hash = $drift_post.expected_hash }
    if($drift_post.ContainsKey("current_hash")){  $details.dns_current_hash  = $drift_post.current_hash }
    $details.dns_drift_pre  = [bool]$(if($drift_pre  -is [hashtable]){ $drift_pre.drift } else { $false })
    $details.dns_drift_post = [bool]$(if($drift_post -is [hashtable]){ $drift_post.drift } else { $false })
  }

  if($sqlite_error){ $details.sqlite_error = $sqlite_error }

  $cor = Write-GfwEvidence `
    -Component "health" `
    -Action "health_cycle" `
    -Result $canon.result `
    -ExitCode ([int]$canon.exit_code) `
    -Details $details `
    -CorrelationId $cor

  exit $code

} catch {
  $cor = Write-GfwEvidence `
    -Component "health" `
    -Action "exception" `
    -Result "FAIL" `
    -ExitCode $EXIT_FAIL `
    -Details @{ error=$_.Exception.Message; stack=$_.ScriptStackTrace } `
    -CorrelationId $cor
  exit $EXIT_FAIL

} finally {
  if($hasLock -and $null -ne $mutex){
    try { $mutex.ReleaseMutex() } catch {}
  }
  if($null -ne $mutex){
    try { $mutex.Dispose() } catch {}
  }
}









.Exception.Message }
}

# if drift exists and policyMode=enforce, we will repair by applying policy once
if($policyMode -eq "enforce" -and $drift_pre -is [hashtable] -and $drift_pre.drift -eq $true){
  try {
    $r2 = Apply-GfwDnsPolicy
    if($r2 -is [hashtable]){ $dns = $r2 }
  } catch { }
}

try {
  if(Get-Command Check-GfwDnsDrift -ErrorAction SilentlyContinue){
    $dpost = Check-GfwDnsDrift
    if($dpost -is [hashtable]){ $drift_post = $dpost } else { $drift_post = @{ drift=$false; reason="BAD_RETURN_TYPE_POST" } }
  } else {
    $drift_post = @{ drift=$false; reason="NO_FUNCTION" }
  }
} catch {
  $drift_post = @{ drift=$false; reason="DRIFT_POST_FAIL"; error=# run-health-phase1.ps1
# Phase 1 deterministic wrapper + mutex + DNS enforcement + DNS drift (single evidence line)

$ErrorActionPreference="Stop"
Set-StrictMode -Version Latest

Import-Module "C:\ProgramData\GuardianFW\engine\Guardian.ExitCodes.psm1" -Force
Import-Module "C:\ProgramData\GuardianFW\engine\Guardian.Evidence.psm1" -Force
Import-Module "C:\ProgramData\GuardianFW\engine\Guardian.Config.psm1" -Force
Import-Module "C:\ProgramData\GuardianFW\engine\Guardian.DB.psm1" -Force
Import-Module "C:\ProgramData\GuardianFW\engine\Guardian.Map.psm1" -Force

# ---- Mutex: prevent overlapping runs (Local works for Admin + SYSTEM) ----
$mutexName = "Local\GuardianFW_Health_Lock"
$mutex = $null
$hasLock = $false

$cor   = ""
$start = Get-Date


# policy mode (safe read)
$policyMode = "enforce"
try {
  $pp = "C:\ProgramData\GuardianFW\policy\dns-policy.json"
  if(Test-Path $pp){
    $po = (Get-Content -LiteralPath $pp -Raw -Encoding UTF8) | ConvertFrom-Json
    if($po.mode){ $policyMode = ([string]$po.mode).ToLower() }
  }
} catch { $policyMode = "enforce" }

try {
  # Create mutex (best-effort)
  try {
    $mutex = New-Object System.Threading.Mutex($false, $mutexName)
  } catch {
    $mutex = $null
  }

  # Acquire lock (or proceed without mutex)
  if($null -ne $mutex){
    $hasLock = $mutex.WaitOne(5000)
  } else {
    $hasLock = $true
  }

  if(-not $hasLock){
    exit $EXIT_NOOP
  }

  # ---- DNS enforcement (fold into details; no extra evidence) ----
  $dns = @{ status="NOT_RUN" }
  try {
    . "C:\ProgramData\GuardianFW\engine\Enforce-DnsPolicy.ps1"
    $r = Apply-GfwDnsPolicy
$dnsPolicyVersion = $null
try {
  $p = "C:\ProgramData\GuardianFW\policy\dns-policy.json"
  if(Test-Path $p){
    $po = (Get-Content -LiteralPath $p -Raw -Encoding UTF8) | ConvertFrom-Json
    $dnsPolicyVersion = $po.version
  }
} catch { $dnsPolicyVersion = $null }
$dnsPolicyVersion = $null
try {
  $p = "C:\ProgramData\GuardianFW\policy\dns-policy.json"
  if(Test-Path $p){
    $po = (Get-Content -LiteralPath $p -Raw -Encoding UTF8) | ConvertFrom-Json
    $dnsPolicyVersion = $po.version
  }
} catch { $dnsPolicyVersion = $null }
    if($r -is [hashtable]){ $dns = $r } else { $dns = @{ status="BAD_RETURN_TYPE" } }
  } catch {
    $dns = @{ status="FAIL"; error=$_.Exception.Message }
  }

  # ---- DNS drift (fold into details; no extra evidence) ----
  $drift = @{ drift=$false; reason="NOT_RUN" }
  try {
    . "C:\ProgramData\GuardianFW\engine\Check-DnsDrift.ps1"
    if(Get-Command Check-GfwDnsDrift -ErrorAction SilentlyContinue){
      $d = Check-GfwDnsDrift
      if($d -is [hashtable]){ $drift = $d } else { $drift = @{ drift=$false; reason="BAD_RETURN_TYPE" } }
    } else {
      $drift = @{ drift=$false; reason="NO_FUNCTION" }
    }
  } catch {
    $drift = @{ drift=$false; reason="DRIFT_CHECK_FAIL"; error=$_.Exception.Message }
  }

  # If drift detected, re-apply once (best-effort) so the system self-heals
$dns_repaired = $false
if($policyMode -eq "enforce" -and $drift -is [hashtable] -and $drift.drift -eq $true){
  try {
    $r2 = Apply-GfwDnsPolicy
    if($r2 -is [hashtable]){ $dns = $r2 }
    $dns_repaired = $true
  } catch { }
}
# 1) Baseline integrity
  $b = Test-GfwBaseline
  if(-not $b.ok){
    $cor = Write-GfwEvidence `
      -Component "health" `
      -Action "verify_baseline" `
      -Result "TAMPER" `
      -ExitCode $EXIT_TAMPER `
      -Details $b `
      -CorrelationId $cor
    exit $EXIT_TAMPER
  }

  # 2) Optional DB init (no evidence here)
  $sqlite = "C:\ProgramData\GuardianFW\tools\sqlite3.exe"
  $sqlite_status = "missing"
  $sqlite_error  = ""
  if(Test-Path $sqlite){
    $sqlite_status = "present"
    try { Initialize-GfwDb } catch { $sqlite_error = $_.Exception.Message }
  }

  # 3) Call inner health
  $inner = "C:\ProgramData\GuardianFW\engine\run-health.ps1"
  & powershell.exe -NoProfile -ExecutionPolicy Bypass -File $inner
  $code = $LASTEXITCODE

  # 4) Canonicalize + single evidence
  $elapsedMs = [int]((Get-Date) - $start).TotalMilliseconds
  $canon = Convert-GfwInnerExitToCanonical -InnerExit $code
# ---- FINAL normalize of dns_repaired (must match drift_pre/drift_post truth) ----
$preDrift  = $false
$postDrift = $false
try { if($drift_pre  -is [hashtable] -and $drift_pre.ContainsKey("drift"))  { $preDrift  = [bool]$drift_pre.drift } } catch {}
try { if($drift_post -is [hashtable] -and $drift_post.ContainsKey("drift")) { $postDrift = [bool]$drift_post.drift } } catch {}
$dns_repaired = ($policyMode -eq "enforce" -and $preDrift -eq $true -and $postDrift -eq $false)

  $details = @{
    inner_exit         = $code
    canonical          = $canon.result
    canonical_exit     = [int]$canon.exit_code
    elapsed_ms         = $elapsedMs
    sqlite             = $sqlite_status

    dns_status         = $dns.status
    dns_drift          = $drift_post.drift
    dns_drift_reason   = $drift_post.reason
    dns_repaired      = [bool]$dns_repaired
    dns_would_change  = ($(if($dns -is [hashtable] -and $dns.ContainsKey("would_change")){ [bool]$dns.would_change } else { $false }))
    dns_repaired      = [bool]$dns_repaired
    dns_would_change  = ($(if($dns -is [hashtable] -and $dns.ContainsKey("would_change")){ [bool]$dns.would_change } else { $false }))
  }

  if($dns -is [hashtable]){
    if($dns.ContainsKey("count")) {  $details.dns_count  = $dns.count }
    if($dns.ContainsKey("hosts")) {  $details.dns_hosts  = $dns.hosts }
    if($dns.ContainsKey("policy")){  $details.dns_policy = $dns.policy }
    if($null -ne $dnsPolicyVersion){ $details.dns_policy_version = [int]$dnsPolicyVersion }
    if($dns.ContainsKey("error")){  $details.dns_error  = $dns.error }
    if($dns.ContainsKey("would_change")){ $details.dns_would_change = [bool]$dns.would_change }
  }

  if($drift_post -is [hashtable]){
    if($drift_post.ContainsKey("prev")){  $details.dns_prev_hash = $drift_post.prev }
    if($drift_post.ContainsKey("hash")){  $details.dns_hash      = $drift_post.hash }
    if($drift_post.ContainsKey("error")){ $details.dns_drift_error = $drift_post.error }
    if($drift_post.ContainsKey("expected_hash")){ $details.dns_expected_hash = $drift_post.expected_hash }
    if($drift_post.ContainsKey("current_hash")){  $details.dns_current_hash  = $drift_post.current_hash }
    $details.dns_drift_pre  = [bool]$(if($drift_pre  -is [hashtable]){ $drift_pre.drift } else { $false })
    $details.dns_drift_post = [bool]$(if($drift_post -is [hashtable]){ $drift_post.drift } else { $false })
  }

  if($sqlite_error){ $details.sqlite_error = $sqlite_error }

  $cor = Write-GfwEvidence `
    -Component "health" `
    -Action "health_cycle" `
    -Result $canon.result `
    -ExitCode ([int]$canon.exit_code) `
    -Details $details `
    -CorrelationId $cor

  exit $code

} catch {
  $cor = Write-GfwEvidence `
    -Component "health" `
    -Action "exception" `
    -Result "FAIL" `
    -ExitCode $EXIT_FAIL `
    -Details @{ error=$_.Exception.Message; stack=$_.ScriptStackTrace } `
    -CorrelationId $cor
  exit $EXIT_FAIL

} finally {
  if($hasLock -and $null -ne $mutex){
    try { $mutex.ReleaseMutex() } catch {}
  }
  if($null -ne $mutex){
    try { $mutex.Dispose() } catch {}
  }
}









.Exception.Message }
}

# repaired? only if drift was true before, and false after (and enforce mode)
$dns_repaired = ($policyMode -eq "enforce" -and $drift_pre.drift -eq $true -and $drift_post.drift -eq $false)

# 1) Baseline integrity
  $b = Test-GfwBaseline
  if(-not $b.ok){
    $cor = Write-GfwEvidence `
      -Component "health" `
      -Action "verify_baseline" `
      -Result "TAMPER" `
      -ExitCode $EXIT_TAMPER `
      -Details $b `
      -CorrelationId $cor
    exit $EXIT_TAMPER
  }

  # 2) Optional DB init (no evidence here)
  $sqlite = "C:\ProgramData\GuardianFW\tools\sqlite3.exe"
  $sqlite_status = "missing"
  $sqlite_error  = ""
  if(Test-Path $sqlite){
    $sqlite_status = "present"
    try { Initialize-GfwDb } catch { $sqlite_error = $_.Exception.Message }
  }

  # 3) Call inner health
  $inner = "C:\ProgramData\GuardianFW\engine\run-health.ps1"
  & powershell.exe -NoProfile -ExecutionPolicy Bypass -File $inner
  $code = $LASTEXITCODE

  # 4) Canonicalize + single evidence
  $elapsedMs = [int]((Get-Date) - $start).TotalMilliseconds
  $canon = Convert-GfwInnerExitToCanonical -InnerExit $code
# ---- FINAL normalize of dns_repaired (must match drift_pre/drift_post truth) ----
$preDrift  = $false
$postDrift = $false
try { if($drift_pre  -is [hashtable] -and $drift_pre.ContainsKey("drift"))  { $preDrift  = [bool]$drift_pre.drift } } catch {}
try { if($drift_post -is [hashtable] -and $drift_post.ContainsKey("drift")) { $postDrift = [bool]$drift_post.drift } } catch {}
$dns_repaired = ($policyMode -eq "enforce" -and $preDrift -eq $true -and $postDrift -eq $false)

  $details = @{
    inner_exit         = $code
    canonical          = $canon.result
    canonical_exit     = [int]$canon.exit_code
    elapsed_ms         = $elapsedMs
    sqlite             = $sqlite_status

    dns_status         = $dns.status
    dns_drift          = $drift_post.drift
    dns_drift_reason   = $drift_post.reason
    dns_repaired      = [bool]$dns_repaired
    dns_would_change  = ($(if($dns -is [hashtable] -and $dns.ContainsKey("would_change")){ [bool]$dns.would_change } else { $false }))
    dns_repaired      = [bool]$dns_repaired
    dns_would_change  = ($(if($dns -is [hashtable] -and $dns.ContainsKey("would_change")){ [bool]$dns.would_change } else { $false }))
  }

  if($dns -is [hashtable]){
    if($dns.ContainsKey("count")) {  $details.dns_count  = $dns.count }
    if($dns.ContainsKey("hosts")) {  $details.dns_hosts  = $dns.hosts }
    if($dns.ContainsKey("policy")){  $details.dns_policy = $dns.policy }
    if($null -ne $dnsPolicyVersion){ $details.dns_policy_version = [int]$dnsPolicyVersion }
    if($dns.ContainsKey("error")){  $details.dns_error  = $dns.error }
    if($dns.ContainsKey("would_change")){ $details.dns_would_change = [bool]$dns.would_change }
  }

  if($drift_post -is [hashtable]){
    if($drift_post.ContainsKey("prev")){  $details.dns_prev_hash = $drift_post.prev }
    if($drift_post.ContainsKey("hash")){  $details.dns_hash      = $drift_post.hash }
    if($drift_post.ContainsKey("error")){ $details.dns_drift_error = $drift_post.error }
    if($drift_post.ContainsKey("expected_hash")){ $details.dns_expected_hash = $drift_post.expected_hash }
    if($drift_post.ContainsKey("current_hash")){  $details.dns_current_hash  = $drift_post.current_hash }
    $details.dns_drift_pre  = [bool]$(if($drift_pre  -is [hashtable]){ $drift_pre.drift } else { $false })
    $details.dns_drift_post = [bool]$(if($drift_post -is [hashtable]){ $drift_post.drift } else { $false })
  }

  if($sqlite_error){ $details.sqlite_error = $sqlite_error }

  $cor = Write-GfwEvidence `
    -Component "health" `
    -Action "health_cycle" `
    -Result $canon.result `
    -ExitCode ([int]$canon.exit_code) `
    -Details $details `
    -CorrelationId $cor

  exit $code

} catch {
  $cor = Write-GfwEvidence `
    -Component "health" `
    -Action "exception" `
    -Result "FAIL" `
    -ExitCode $EXIT_FAIL `
    -Details @{ error=$_.Exception.Message; stack=$_.ScriptStackTrace } `
    -CorrelationId $cor
  exit $EXIT_FAIL

} finally {
  if($hasLock -and $null -ne $mutex){
    try { $mutex.ReleaseMutex() } catch {}
  }
  if($null -ne $mutex){
    try { $mutex.Dispose() } catch {}
  }
}











