# --- Single-instance guard (mutex) ---
$mutexName = "Global\GuardianFW-ProcessDNS"
$mutex = New-Object System.Threading.Mutex($false, $mutexName)
$hasLock = $false
try {
  $hasLock = $mutex.WaitOne(0)
  if(-not $hasLock){ exit 0 }

Set-StrictMode -Version Latest
# ---- AUDIT_DEDUPE_MODULE ----
. "C:\ProgramData\GuardianFW\engine\audit-dedupe.ps1"
$ErrorActionPreference="Stop"

$Root="C:\ProgramData\GuardianFW"
if(!(Test-Path -LiteralPath (Join-Path $Root "state"))){ New-Item -ItemType Directory -Path (Join-Path $Root "state") -Force | Out-Null }
$Policy=Join-Path $Root "policy\policy.json"
$DohIps=Join-Path $Root "policy\doh-ips.json"
$Audit=Join-Path $Root "logs\guardian-audit.jsonl"
$Fail =Join-Path $Root "sealed\FAIL_SECURE.flag"

function Write-Audit([string]$event,[hashtable]$data=@{}) {
  # ---- AUDIT_DEDUPE ----
  function Get-DedupeKey([string]$ev,$data){
    $pairs = @($ev.ToLowerInvariant().Trim())
    if($data){
      foreach($k in ($data.Keys | Sort-Object)){
        $v = ""
        try { $v = ([string]$data[$k]).Trim() } catch { $v = "" }
        $pairs += ("{0}={1}" -f $k.ToLowerInvariant().Trim(), $v)
      }
    }
    $raw = ($pairs -join "|")
    $sha=[System.Security.Cryptography.SHA256]::Create()
    try{
      return (-join ($sha.ComputeHash([Text.Encoding]::UTF8.GetBytes($raw)) | ForEach-Object { # --- Single-instance guard (mutex) ---
$mutexName = "Global\GuardianFW-ProcessDNS"
$mutex = New-Object System.Threading.Mutex($false, $mutexName)
$hasLock = $false
try {
  $hasLock = $mutex.WaitOne(0)
  if(-not $hasLock){ exit 0 }

Set-StrictMode -Version Latest
# ---- AUDIT_DEDUPE_MODULE ----
. "C:\ProgramData\GuardianFW\engine\audit-dedupe.ps1"
$ErrorActionPreference="Stop"

$Root="C:\ProgramData\GuardianFW"
if(!(Test-Path -LiteralPath (Join-Path $Root "state"))){ New-Item -ItemType Directory -Path (Join-Path $Root "state") -Force | Out-Null }
$Policy=Join-Path $Root "policy\policy.json"
$DohIps=Join-Path $Root "policy\doh-ips.json"
$Audit=Join-Path $Root "logs\guardian-audit.jsonl"
$Fail =Join-Path $Root "sealed\FAIL_SECURE.flag"

function Write-Audit([string]$event,[hashtable]$data=@{}) {
  # ---- AUDIT_LOG_ROTATION ----
  function Rotate-AuditIfNeeded {
    param(
      [string]$AuditPath,
      [int64]$MaxBytes = 10MB,
      [int]$Keep = 20
    )
    try{
      if([string]::IsNullOrWhiteSpace($AuditPath)){ return }
      if(!(Test-Path -LiteralPath $AuditPath)){ return }

      $fi = Get-Item -LiteralPath $AuditPath -ErrorAction Stop
      if($fi.Length -lt $MaxBytes){ return }

      $dir  = Split-Path -Parent $AuditPath
      $base = Split-Path -Leaf   $AuditPath
      $ts   = (Get-Date).ToUniversalTime().ToString("yyyyMMdd_HHmmss")
      $rot  = Join-Path $dir ("{0}.{1}.old" -f $base,$ts)

      Move-Item -LiteralPath $AuditPath -Destination $rot -Force -ErrorAction Stop

      # create fresh file immediately
      New-Item -ItemType File -Path $AuditPath -Force | Out-Null

      # cleanup old rotations
      Get-ChildItem -LiteralPath $dir -File -Filter ($base + ".*.old") |
        Sort-Object LastWriteTime -Descending |
        Select-Object -Skip $Keep |
        Remove-Item -Force -ErrorAction SilentlyContinue

    } catch {
      # never let rotation break enforcement
      return
    }
  }

  # call rotation before writing
  Rotate-AuditIfNeeded -AuditPath $Audit -MaxBytes 10MB -Keep 20

  $dir = Split-Path $Audit
  if(!(Test-Path $dir)){ New-Item -ItemType Directory -Path $dir -Force | Out-Null }
    # ---- Compact huge events ----
  if($event -eq "lolbin_detected" -and $data -is [hashtable] -and $data.ContainsKey("message")){
    $m = [string]$data["message"]
    if($m.Length -gt 600){ $data["message"] = $m.Substring(0,600) + "...(truncated)" }
  }
$rec=[pscustomobject]@{ tsUtc=(Get-Date).ToUniversalTime().ToString("o"); event=$event; data=$data }
    # ---- AUDIT_MUTEX_LOCK ----
  $mutexName = "Global\GuardianFW_AuditLock"
  $mtx = $null
  $locked = $false
  try {
    $mtx = New-Object System.Threading.Mutex($false, $mutexName)
    $locked = $mtx.WaitOne(5000)  # wait up to 5s
  } catch { $locked = $false }

if($locked){
    if(-not (Should-LogEvent $event $data)){ return }
    if(-not (Should-LogEvent $ev $data)){ return }
  try {
    ($rec|ConvertTo-Json -Compress -Depth 12) | Add-Content -LiteralPath $Audit -Encoding UTF8
  } finally {
    try { $mtx.ReleaseMutex() } catch {}
    try { $mtx.Dispose() } catch {}
  }
} else {
  # fallback (still write, but without lock)
  ($rec|ConvertTo-Json -Compress -Depth 12) | Add-Content -LiteralPath $Audit -Encoding UTF8
}
}

function HasProp($o,[string]$n){ return ($o -and $o.PSObject.Properties.Match($n).Count -gt 0) }

function Safe-LoadJson([string]$path){
  try { return (Get-Content -LiteralPath $path -Raw -Encoding UTF8 | ConvertFrom-Json) }
  catch { Write-Audit "json_load_failed" @{path=$path; error=$_.Exception.Message}; return $null }
}

# -------------------------
# Load policy
# -------------------------
$cfg = Safe-LoadJson $Policy
if($null -eq $cfg){ exit 0 }

if(-not (HasProp $cfg "process_dns_policy")){
  Write-Audit "process_dns_policy_missing" @{}
  exit 0
}

$pdp = $cfg.process_dns_policy
$mode="monitor"; $action="log"
if(HasProp $pdp "mode"){ $mode=[string]$pdp.mode }
if(HasProp $pdp "action"){ $action=[string]$pdp.action }

$rules=@()
if(HasProp $pdp "allow" -and $pdp.allow){ $rules=@($pdp.allow) }

function Is-AllowedImage([string]$img){
  foreach($r in $rules){
    if($r -and (HasProp $r "image") -and $r.image){
      if($img -ieq [string]$r.image){ return $true }
    }
  }
  return $false
}

# -------------------------
# Load DoH IP list (optional)
# -------------------------
$dohSet = @{}
$doh = Safe-LoadJson $DohIps
if($doh -and (HasProp $doh "providers") -and $doh.providers){
  foreach($prov in @($doh.providers)){
    if($prov -and (HasProp $prov "ips") -and $prov.ips){
      $pname = $null
      if(HasProp $prov "name"){ $pname = [string]$prov.name }
      foreach($ip in @($prov.ips)){
        if($ip){ $dohSet[[string]$ip] = $pname }
      }
    }
  }
}

# -------------------------
# DNS53 detection:
# - UDP: LocalPort == 53
# - TCP: RemotePort == 53
# -------------------------
$udp = Get-NetUDPEndpoint -ErrorAction SilentlyContinue | Where-Object { $_.LocalPort -eq 53 }
foreach($u in $udp){
  $ProcId=[int]$u.OwningProcess
  if($ProcId -le 4){ continue }

  $p = Get-Process -Id $ProcId -ErrorAction SilentlyContinue
  if(!$p -or -not $p.Path){ continue }
  $img=[string]$p.Path

  if(-not (Is-AllowedImage $img)){
    Write-Audit "process_dns_violation" @{
      kind="dns53_udp"; pid=$ProcId; image=$img;
      local=$u.LocalAddress; lport=$u.LocalPort;
      mode=$mode; action=$action
    }

    if($mode -ieq "enforce" -and $action -ieq "kill"){
      try { Stop-Process -Id $ProcId -Force; Write-Audit "process_dns_killed" @{kind="dns53_udp"; pid=$ProcId; image=$img} }
      catch { Write-Audit "process_dns_kill_failed" @{kind="dns53_udp"; pid=$ProcId; image=$img; error=$_.Exception.Message}; New-Item -ItemType File -Path $Fail -Force | Out-Null }
    }
  }
}

$tcp53 = Get-NetTCPConnection -State Established -ErrorAction SilentlyContinue | Where-Object { $_.RemotePort -eq 53 }
foreach($c in $tcp53){
  $ProcId=[int]$c.OwningProcess
  if($ProcId -le 4){ continue }

  $p = Get-Process -Id $ProcId -ErrorAction SilentlyContinue
  if(!$p -or -not $p.Path){ continue }
  $img=[string]$p.Path

  if(-not (Is-AllowedImage $img)){
    Write-Audit "process_dns_violation" @{
      kind="dns53_tcp"; pid=$ProcId; image=$img; remote=$c.RemoteAddress; port=$c.RemotePort;
      mode=$mode; action=$action
    }

    if($mode -ieq "enforce" -and $action -ieq "kill"){
      try { Stop-Process -Id $ProcId -Force; Write-Audit "process_dns_killed" @{kind="dns53_tcp"; pid=$ProcId; image=$img} }
      catch { Write-Audit "process_dns_kill_failed" @{kind="dns53_tcp"; pid=$ProcId; image=$img; error=$_.Exception.Message}; New-Item -ItemType File -Path $Fail -Force | Out-Null }
    }
  }
}

# -------------------------
# DoH IP correlation (SAFE):
# - TCP 443 only if RemoteAddress is in doh-ips.json
# - Include short-lived states to increase capture chance
# -------------------------
if($dohSet.Count -gt 0){
  $tcp443 = Get-NetTCPConnection -ErrorAction SilentlyContinue |
            Where-Object { $_.RemotePort -eq 443 -and $_.State -in @("Established","SynSent","TimeWait") }

  foreach($c in $tcp443){
    $rip = [string]$c.RemoteAddress
    if(-not $rip){ continue }
    if(-not $dohSet.ContainsKey($rip)){ continue }

    $ProcId=[int]$c.OwningProcess
    if($ProcId -le 4){ continue }

    $p = Get-Process -Id $ProcId -ErrorAction SilentlyContinue
    $img = $null
    if($p -and $p.Path){ $img = [string]$p.Path }

    $provider = $dohSet[$rip]

    Write-Audit "process_dns_violation" @{
      kind="doh_ip_hit"; pid=$ProcId; image=$img; remote=$rip; port=443; provider=$provider;
      mode=$mode; action=$action
    }

    if($Host.Name -match "ConsoleHost"){
      Write-Host ("DoH hit: {0} {1} {2}" -f $provider, $rip, $img)
    }

    if($mode -ieq "enforce" -and $action -ieq "kill"){
      try { Stop-Process -Id $ProcId -Force; Write-Audit "process_dns_killed" @{kind="doh_ip_hit"; pid=$ProcId; image=$img; remote=$rip; provider=$provider} }
      catch { Write-Audit "process_dns_kill_failed" @{kind="doh_ip_hit"; pid=$ProcId; image=$img; remote=$rip; provider=$provider; error=$_.Exception.Message}; New-Item -ItemType File -Path $Fail -Force | Out-Null }
    }
  }
}

# -------------------------
# DEBUG: observe 443 remotes (always)
# -------------------------
try {
  $tcp443all = Get-NetTCPConnection -State Established -ErrorAction SilentlyContinue | Where-Object { $_.RemotePort -eq 443 }
  foreach($c in $tcp443all){
    $ProcId=[int]$c.OwningProcess
    if($ProcId -le 4){ continue }

    $p = Get-Process -Id $ProcId -ErrorAction SilentlyContinue
    $img=$null
    if($p -and $p.Path){ $img=[string]$p.Path }

    $rip=[string]$c.RemoteAddress
    if(-not $rip){ continue }

    $prov=$null
    if($dohSet.Count -gt 0 -and $dohSet.ContainsKey($rip)){ $prov=$dohSet[$rip] }

    Write-Audit "tcp443_seen" @{ pid=$ProcId; image=$img; remote=$rip; provider=$prov }
  }
} catch {
  Write-Audit "tcp443_seen_failed" @{ error=$_.Exception.Message }
}

# Optional pause when manual:
#   setx GUARDIANFW_PAUSE 1
if($Host.Name -match "ConsoleHost" -and $env:GUARDIANFW_PAUSE -eq "1"){
  Read-Host "Press Enter" | Out-Null
}

exit 0

} finally {
  if($hasLock){ $mutex.ReleaseMutex() | Out-Null }
  $mutex.Dispose()
}




.ToString("x2") }))
    } finally { $sha.Dispose() }
  }

  function Load-DedupeMap([string]$stateFile){
    $map = @{}
    if(Test-Path -LiteralPath $stateFile){
      try {
        $obj = Get-Content -LiteralPath $stateFile -Raw -Encoding UTF8 | ConvertFrom-Json
        if($obj){
          foreach($p in $obj.PSObject.Properties){
            $map[$p.Name] = $p.Value
          }
        }
      } catch {
        $map = @{}
      }
    }
    return $map
  }

  function Save-DedupeMap([hashtable]$map,[string]$stateFile){
    $tmp = "$stateFile.tmp"
    ($map | ConvertTo-Json -Depth 4) | Set-Content -LiteralPath $tmp -Encoding UTF8 -Force
    Move-Item -LiteralPath $tmp -Destination $stateFile -Force
  }

  function Should-LogEvent([string]$ev,$data){
    $stateDir  = Join-Path $Root "state"
    $stateFile = Join-Path $stateDir "audit-dedupe.json"
    if(!(Test-Path -LiteralPath $stateDir)){ New-Item -ItemType Directory -Path $stateDir -Force | Out-Null }

    $ttl = switch($ev){
      "lolbin_detected" { 3600 }  # 60 min
      "dns_blocked"     { 300  }  # 5 min
      "doh_blocked"     { 300  }  # 5 min
      default           { 120  }
    }

    $key = Get-DedupeKey $ev $data
    $now = [DateTime]::UtcNow

    # Global mutex for cross-service/task safety
    $mutexName = "Global\GuardianFW_AuditDedupe"
    $mtx = New-Object System.Threading.Mutex($false, $mutexName)
    try {
      if(-not $mtx.WaitOne(5000)){
        # Fail-safe: if we can't coordinate, allow logging (never suppress)
        return $true
      }

      $map = Load-DedupeMap $stateFile

      # Garbage collect old entries (bounds growth)
      $maxAge = [TimeSpan]::FromDays(7)
      foreach($k in @($map.Keys)){
        try {
          $t = [DateTime]::Parse([string]$map[$k])
          if(($now - $t) -gt $maxAge){ $map.Remove($k) }
        } catch {
          $map.Remove($k)
        }
      }

      if($map.ContainsKey($key)){
        try {
          $last = [DateTime]::Parse([string]$map[$key])
          if(($now - $last).TotalSeconds -lt $ttl){ return $false }
        } catch {
          # If corrupted timestamp, treat as loggable and overwrite
        }
      }

      $map[$key] = $now.ToString("o")

      try { Save-DedupeMap $map $stateFile } catch {
        # If state write fails, fail-safe: allow logging (never suppress)
        return $true
      }

      return $true
    } finally {
      try { $mtx.ReleaseMutex() } catch {}
      $mtx.Dispose()
    }
  }
  # ---- AUDIT_LOG_ROTATION ----
  function Rotate-AuditIfNeeded {
    param(
      [string]$AuditPath,
      [int64]$MaxBytes = 10MB,
      [int]$Keep = 20
    )
    try{
      if([string]::IsNullOrWhiteSpace($AuditPath)){ return }
      if(!(Test-Path -LiteralPath $AuditPath)){ return }

      $fi = Get-Item -LiteralPath $AuditPath -ErrorAction Stop
      if($fi.Length -lt $MaxBytes){ return }

      $dir  = Split-Path -Parent $AuditPath
      $base = Split-Path -Leaf   $AuditPath
      $ts   = (Get-Date).ToUniversalTime().ToString("yyyyMMdd_HHmmss")
      $rot  = Join-Path $dir ("{0}.{1}.old" -f $base,$ts)

      Move-Item -LiteralPath $AuditPath -Destination $rot -Force -ErrorAction Stop

      # create fresh file immediately
      New-Item -ItemType File -Path $AuditPath -Force | Out-Null

      # cleanup old rotations
      Get-ChildItem -LiteralPath $dir -File -Filter ($base + ".*.old") |
        Sort-Object LastWriteTime -Descending |
        Select-Object -Skip $Keep |
        Remove-Item -Force -ErrorAction SilentlyContinue

    } catch {
      # never let rotation break enforcement
      return
    }
  }

  # call rotation before writing
  Rotate-AuditIfNeeded -AuditPath $Audit -MaxBytes 10MB -Keep 20

  $dir = Split-Path $Audit
  if(!(Test-Path $dir)){ New-Item -ItemType Directory -Path $dir -Force | Out-Null }
    # ---- Compact huge events ----
  if($event -eq "lolbin_detected" -and $data -is [hashtable] -and $data.ContainsKey("message")){
    $m = [string]$data["message"]
    if($m.Length -gt 600){ $data["message"] = $m.Substring(0,600) + "...(truncated)" }
  }
$rec=[pscustomobject]@{ tsUtc=(Get-Date).ToUniversalTime().ToString("o"); event=$event; data=$data }
    # ---- AUDIT_MUTEX_LOCK ----
  $mutexName = "Global\GuardianFW_AuditLock"
  $mtx = $null
  $locked = $false
  try {
    $mtx = New-Object System.Threading.Mutex($false, $mutexName)
    $locked = $mtx.WaitOne(5000)  # wait up to 5s
  } catch { $locked = $false }

if($locked){
    if(-not (Should-LogEvent $event $data)){ return }
    if(-not (Should-LogEvent $ev $data)){ return }
  try {
    ($rec|ConvertTo-Json -Compress -Depth 12) | Add-Content -LiteralPath $Audit -Encoding UTF8
  } finally {
    try { $mtx.ReleaseMutex() } catch {}
    try { $mtx.Dispose() } catch {}
  }
} else {
  # fallback (still write, but without lock)
  ($rec|ConvertTo-Json -Compress -Depth 12) | Add-Content -LiteralPath $Audit -Encoding UTF8
}
}

function HasProp($o,[string]$n){ return ($o -and $o.PSObject.Properties.Match($n).Count -gt 0) }

function Safe-LoadJson([string]$path){
  try { return (Get-Content -LiteralPath $path -Raw -Encoding UTF8 | ConvertFrom-Json) }
  catch { Write-Audit "json_load_failed" @{path=$path; error=$_.Exception.Message}; return $null }
}

# -------------------------
# Load policy
# -------------------------
$cfg = Safe-LoadJson $Policy
if($null -eq $cfg){ exit 0 }

if(-not (HasProp $cfg "process_dns_policy")){
  Write-Audit "process_dns_policy_missing" @{}
  exit 0
}

$pdp = $cfg.process_dns_policy
$mode="monitor"; $action="log"
if(HasProp $pdp "mode"){ $mode=[string]$pdp.mode }
if(HasProp $pdp "action"){ $action=[string]$pdp.action }

$rules=@()
if(HasProp $pdp "allow" -and $pdp.allow){ $rules=@($pdp.allow) }

function Is-AllowedImage([string]$img){
  foreach($r in $rules){
    if($r -and (HasProp $r "image") -and $r.image){
      if($img -ieq [string]$r.image){ return $true }
    }
  }
  return $false
}

# -------------------------
# Load DoH IP list (optional)
# -------------------------
$dohSet = @{}
$doh = Safe-LoadJson $DohIps
if($doh -and (HasProp $doh "providers") -and $doh.providers){
  foreach($prov in @($doh.providers)){
    if($prov -and (HasProp $prov "ips") -and $prov.ips){
      $pname = $null
      if(HasProp $prov "name"){ $pname = [string]$prov.name }
      foreach($ip in @($prov.ips)){
        if($ip){ $dohSet[[string]$ip] = $pname }
      }
    }
  }
}

# -------------------------
# DNS53 detection:
# - UDP: LocalPort == 53
# - TCP: RemotePort == 53
# -------------------------
$udp = Get-NetUDPEndpoint -ErrorAction SilentlyContinue | Where-Object { $_.LocalPort -eq 53 }
foreach($u in $udp){
  $ProcId=[int]$u.OwningProcess
  if($ProcId -le 4){ continue }

  $p = Get-Process -Id $ProcId -ErrorAction SilentlyContinue
  if(!$p -or -not $p.Path){ continue }
  $img=[string]$p.Path

  if(-not (Is-AllowedImage $img)){
    Write-Audit "process_dns_violation" @{
      kind="dns53_udp"; pid=$ProcId; image=$img;
      local=$u.LocalAddress; lport=$u.LocalPort;
      mode=$mode; action=$action
    }

    if($mode -ieq "enforce" -and $action -ieq "kill"){
      try { Stop-Process -Id $ProcId -Force; Write-Audit "process_dns_killed" @{kind="dns53_udp"; pid=$ProcId; image=$img} }
      catch { Write-Audit "process_dns_kill_failed" @{kind="dns53_udp"; pid=$ProcId; image=$img; error=$_.Exception.Message}; New-Item -ItemType File -Path $Fail -Force | Out-Null }
    }
  }
}

$tcp53 = Get-NetTCPConnection -State Established -ErrorAction SilentlyContinue | Where-Object { $_.RemotePort -eq 53 }
foreach($c in $tcp53){
  $ProcId=[int]$c.OwningProcess
  if($ProcId -le 4){ continue }

  $p = Get-Process -Id $ProcId -ErrorAction SilentlyContinue
  if(!$p -or -not $p.Path){ continue }
  $img=[string]$p.Path

  if(-not (Is-AllowedImage $img)){
    Write-Audit "process_dns_violation" @{
      kind="dns53_tcp"; pid=$ProcId; image=$img; remote=$c.RemoteAddress; port=$c.RemotePort;
      mode=$mode; action=$action
    }

    if($mode -ieq "enforce" -and $action -ieq "kill"){
      try { Stop-Process -Id $ProcId -Force; Write-Audit "process_dns_killed" @{kind="dns53_tcp"; pid=$ProcId; image=$img} }
      catch { Write-Audit "process_dns_kill_failed" @{kind="dns53_tcp"; pid=$ProcId; image=$img; error=$_.Exception.Message}; New-Item -ItemType File -Path $Fail -Force | Out-Null }
    }
  }
}

# -------------------------
# DoH IP correlation (SAFE):
# - TCP 443 only if RemoteAddress is in doh-ips.json
# - Include short-lived states to increase capture chance
# -------------------------
if($dohSet.Count -gt 0){
  $tcp443 = Get-NetTCPConnection -ErrorAction SilentlyContinue |
            Where-Object { $_.RemotePort -eq 443 -and $_.State -in @("Established","SynSent","TimeWait") }

  foreach($c in $tcp443){
    $rip = [string]$c.RemoteAddress
    if(-not $rip){ continue }
    if(-not $dohSet.ContainsKey($rip)){ continue }

    $ProcId=[int]$c.OwningProcess
    if($ProcId -le 4){ continue }

    $p = Get-Process -Id $ProcId -ErrorAction SilentlyContinue
    $img = $null
    if($p -and $p.Path){ $img = [string]$p.Path }

    $provider = $dohSet[$rip]

    Write-Audit "process_dns_violation" @{
      kind="doh_ip_hit"; pid=$ProcId; image=$img; remote=$rip; port=443; provider=$provider;
      mode=$mode; action=$action
    }

    if($Host.Name -match "ConsoleHost"){
      Write-Host ("DoH hit: {0} {1} {2}" -f $provider, $rip, $img)
    }

    if($mode -ieq "enforce" -and $action -ieq "kill"){
      try { Stop-Process -Id $ProcId -Force; Write-Audit "process_dns_killed" @{kind="doh_ip_hit"; pid=$ProcId; image=$img; remote=$rip; provider=$provider} }
      catch { Write-Audit "process_dns_kill_failed" @{kind="doh_ip_hit"; pid=$ProcId; image=$img; remote=$rip; provider=$provider; error=$_.Exception.Message}; New-Item -ItemType File -Path $Fail -Force | Out-Null }
    }
  }
}

# -------------------------
# DEBUG: observe 443 remotes (always)
# -------------------------
try {
  $tcp443all = Get-NetTCPConnection -State Established -ErrorAction SilentlyContinue | Where-Object { $_.RemotePort -eq 443 }
  foreach($c in $tcp443all){
    $ProcId=[int]$c.OwningProcess
    if($ProcId -le 4){ continue }

    $p = Get-Process -Id $ProcId -ErrorAction SilentlyContinue
    $img=$null
    if($p -and $p.Path){ $img=[string]$p.Path }

    $rip=[string]$c.RemoteAddress
    if(-not $rip){ continue }

    $prov=$null
    if($dohSet.Count -gt 0 -and $dohSet.ContainsKey($rip)){ $prov=$dohSet[$rip] }

    Write-Audit "tcp443_seen" @{ pid=$ProcId; image=$img; remote=$rip; provider=$prov }
  }
} catch {
  Write-Audit "tcp443_seen_failed" @{ error=$_.Exception.Message }
}

# Optional pause when manual:
#   setx GUARDIANFW_PAUSE 1
if($Host.Name -match "ConsoleHost" -and $env:GUARDIANFW_PAUSE -eq "1"){
  Read-Host "Press Enter" | Out-Null
}

exit 0

} finally {
  if($hasLock){ $mutex.ReleaseMutex() | Out-Null }
  $mutex.Dispose()
}







