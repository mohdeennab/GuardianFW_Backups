$ErrorActionPreference="Stop"
$root="C:\ProgramData\GuardianFW"
$hashBase="$root\integrity\integrity-hashes.json"
$evDir="$root\evidence\integrity"
New-Item -ItemType Directory -Path $evDir -Force | Out-Null

# If baseline missing, create it once (safe) then proceed
if (!(Test-Path $hashBase)) {
  try {
    & "$root\engine\integrity-hash-baseline.ps1" | Out-Null
  } catch {
    throw "Missing integrity baseline and failed to create it: $hashBase"
  }
}

$drift=@()
$missing=@()

$base = Get-Content $hashBase -Raw | ConvertFrom-Json



# GFW_MODE_SWITCH: DEV excludes volatile wrappers; PROD is strict
function Get-GfwMode {
  # 1) env var (preferred)
  $m = $env:GFW_MODE
  if([string]::IsNullOrWhiteSpace($m)){
    # 2) config file
    $cfg = "C:\ProgramData\GuardianFW\config\guardianfw.json"
    if(Test-Path -LiteralPath $cfg){
      try {
        $j = Get-Content -LiteralPath $cfg -Raw -Encoding UTF8 | ConvertFrom-Json
        $m = $j.mode
      } catch { }
    }
  }
  if([string]::IsNullOrWhiteSpace($m)){ $m = "PROD" }
  $m = $m.ToUpperInvariant()
  if($m -ne "DEV" -and $m -ne "PROD"){ $m = "PROD" }
  return $m
}

$mode = Get-GfwMode
$devMode = ($mode -eq "DEV")

# Volatile wrapper scripts (edit this list anytime)
$volatilePaths = @(
  "C:\ProgramData\GuardianFW\engine\run-health.ps1",
  "C:\ProgramData\GuardianFW\engine\*.wrapper.ps1"
  "C:\ProgramData\GuardianFW\engine\health.ps1"
)

$warnings = @()
foreach($f in $base.sha256){
  if(!(Test-Path $f.path)){
    $missing += $f.path
    continue
  }
  $h = (Get-FileHash -Algorithm SHA256 -Path $f.path).Hash
  if($h -ne $f.sha256){
    # GFW_VOLATILE_LOGIC
    $isVolatile = $false
foreach($vp in $volatilePaths){
  if($f.path -like $vp){ $isVolatile = $true; break }
}

if($devMode -and $isVolatile){
      $warnings += @{ type="file_hash"; path=$f.path; expected=$f.sha256; actual=$h; note="DEV_MODE_IGNORED_VOLATILE" }
    } else {
      $drift += @{ type="file_hash"; path=$f.path; expected=$f.sha256; actual=$h }
    }
  }
}

$tasks = @("GuardianFW-AutoHeal-Firewall","GuardianFW-AutoHeal-Registry","GuardianFW-AutoHeal-Integrity")
foreach($t in $tasks){
  $q = (schtasks /Query /TN $t /FO LIST /V) 2>$null
  if(!$q){
    $drift += @{ type="task"; task=$t; issue="missing" }
    continue
  }
  $enabled = ($q | Select-String '^Status:\s+Ready|^Scheduled Task State:\s+Enabled' -Quiet)
  if(-not $enabled){
    $drift += @{ type="task"; task=$t; issue="disabled" }
  }
}

$profiles = Get-NetFirewallProfile
foreach($p in $profiles){
  if($p.Enabled -eq $false){
    $drift += @{ type="firewall_profile"; profile=$p.Name; issue="disabled" }
  }
}


# --- Normalize to arrays (prevents {$null} output) ---
$missing = @($missing) | Where-Object { $_ -ne $null }
$drift   = @($drift)   | Where-Object { $_ -ne $null }

$result=@{
  timestamp=(Get-Date).ToString("s")
  mode=$mode
  status= if(@($drift).Count -eq 0 -and @($missing).Count -eq 0){"OK"}else{"DRIFT"}
  missing=@($missing)
  drift=@($drift)
  warnings=@($warnings)
}
  $resultObj = [pscustomobject]$result

$resultObj | ConvertTo-Json -Depth 10 | Out-File "$evDir\verify-$(Get-Date -Format yyyyMMdd-HHmmss).json" -Encoding UTF8

$resultObj


# --- INTEGRITY_EXITCODES_PHASE3 ---
# Normalize exit codes:
# 0=OK, 20=DRIFT, 50=FAIL/ERROR
try {
  $s = $null

  # Common patterns:
  if(Get-Variable -Name result -Scope Script -ErrorAction SilentlyContinue){
    try { $s = $script:result.status } catch {}
  }
  if($null -eq $s -and (Get-Variable -Name status -Scope Script -ErrorAction SilentlyContinue)){
    try { $s = $script:status } catch {}
  }

  $s = ([string]$s).ToUpperInvariant()

  if($s -eq "OK"){
    exit 0
  }
  elseif($s -eq "DRIFT"){
    exit 20
  }
  elseif([string]::IsNullOrWhiteSpace($s)){
    # If script didn't set status, assume OK only if no errors occurred.
    exit 0
  }
  else {
    # unknown status -> fail-safe
    exit 50
  }
} catch {
  exit 50
}

