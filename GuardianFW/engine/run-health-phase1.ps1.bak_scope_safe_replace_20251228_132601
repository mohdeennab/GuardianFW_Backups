# run-health-phase1.ps1
# GuardianFW – Phase 1 Health Wrapper (CLEAN)

$ErrorActionPreference = "Stop"
Set-StrictMode -Version Latest

# ---- Task trace ----
try {
  $ts = Get-Date -Format "yyyy-MM-dd HH:mm:ss.fff"
  Write-Host "[TASKTRACE] entered run-health-phase1.ps1 at $ts; user=$([Security.Principal.WindowsIdentity]::GetCurrent().Name)"
} catch {}

# ---- Mutex: prevent overlapping runs ----
$mutexName = "Local\GuardianFW_Health_Lock"
$mutex = $null
$hasLock = $false

try {
  try {
    $mutex = New-Object System.Threading.Mutex($false, $mutexName)
  } catch {
    $mutex = $null
  }

  if ($null -ne $mutex) {
    $hasLock = $mutex.WaitOne(5000)
  } else {
    $hasLock = $true
  }

  if (-not $hasLock) {
    Write-Host "[GFW] Health already running — NOOP"
    exit 0
  }

  # ---- Call inner health (authoritative) ----
  $inner = "C:\ProgramData\GuardianFW\engine\run-health.ps1"

  $out = @()
  $code = 0
  try {
    $out = & powershell.exe -NoProfile -ExecutionPolicy Bypass -File $inner 2>&1
    $code = $LASTEXITCODE
  } catch {
    $out += "[INNER_EXCEPTION] $($_.Exception.Message)"
    $code = 1
  }

  try {
    Write-Host "[GFW] inner_exit=$code"

  # ---- show latest evidence path (helps when inner is silent) ----
  try {
    $evRoot = "C:\ProgramData\GuardianFW\evidence"
    if(Test-Path $evRoot){
      $evLatest = Get-ChildItem $evRoot -Recurse -Filter "*.json" -EA SilentlyContinue |
        Sort-Object LastWriteTime -Descending | Select-Object -First 1
      if($evLatest){ Write-Host "[GFW] latest_evidence=$($evLatest.FullName)" }

# ---- tiny health summary line ----
try {
  $hl = Join-Path $evRoot "health\health-latest.json"

  if(!(Test-Path -LiteralPath $hl)){
    Write-Host "[GFW] health=NO_EVIDENCE"
  } else {

    $j = $null
    $ok = $false
    $lastErr = $null

    for($t=1; $t -le 8; $t++){
      try {
        $raw = Get-Content -LiteralPath $hl -Raw -Encoding UTF8 -ErrorAction Stop
        $j   = $raw | ConvertFrom-Json -ErrorAction Stop
        $ok = $true
        break
      } catch {
        $lastErr = # run-health-phase1.ps1
# GuardianFW – Phase 1 Health Wrapper (CLEAN)

$ErrorActionPreference = "Stop"
Set-StrictMode -Version Latest

# ---- Task trace ----
try {
  $ts = Get-Date -Format "yyyy-MM-dd HH:mm:ss.fff"
  Write-Host "[TASKTRACE] entered run-health-phase1.ps1 at $ts; user=$([Security.Principal.WindowsIdentity]::GetCurrent().Name)"
} catch {}

# ---- Mutex: prevent overlapping runs ----
$mutexName = "Local\GuardianFW_Health_Lock"
$mutex = $null
$hasLock = $false

try {
  try {
    $mutex = New-Object System.Threading.Mutex($false, $mutexName)
  } catch {
    $mutex = $null
  }

  if ($null -ne $mutex) {
    $hasLock = $mutex.WaitOne(5000)
  } else {
    $hasLock = $true
  }

  if (-not $hasLock) {
    Write-Host "[GFW] Health already running — NOOP"
    exit 0
  }

  # ---- Call inner health (authoritative) ----
  $inner = "C:\ProgramData\GuardianFW\engine\run-health.ps1"

  $out = @()
  $code = 0
  try {
    $out = & powershell.exe -NoProfile -ExecutionPolicy Bypass -File $inner 2>&1
    $code = $LASTEXITCODE
  } catch {
    $out += "[INNER_EXCEPTION] $($_.Exception.Message)"
    $code = 1
  }

  try {
    Write-Host "[GFW] inner_exit=$code"

  # ---- show latest evidence path (helps when inner is silent) ----
  try {
    $evRoot = "C:\ProgramData\GuardianFW\evidence"
    if(Test-Path $evRoot){
      $evLatest = Get-ChildItem $evRoot -Recurse -Filter "*.json" -EA SilentlyContinue |
        Sort-Object LastWriteTime -Descending | Select-Object -First 1
      if($evLatest){ Write-Host "[GFW] latest_evidence=$($evLatest.FullName)" }

# ---- tiny health summary line ----
try {
  $hl = Join-Path $evRoot "health\health-latest.json"

  if(!(Test-Path -LiteralPath $hl)){
    Write-Host "[GFW] health=NO_EVIDENCE"
  } else {

    $j = $null
    $ok = $false

    for($t=1; $t -le 8; $t++){
      try {
        $raw = Get-Content -LiteralPath $hl -Raw -Encoding UTF8 -ErrorAction Stop
        $j   = $raw | ConvertFrom-Json -ErrorAction Stop
        $ok = $true
        break
      } catch {
        Start-Sleep -Milliseconds 200
      }
    }

    if(-not $ok -or $null -eq $j){
      Write-Host "[GFW] health=ERROR"
    } else {
      $overall = [string]$j.overall
      if([string]::IsNullOrWhiteSpace($overall)){ $overall = "UNKNOWN" }

      $parts = @()
      if($j.firewall  -and $j.firewall.status)  { $parts += "fw="  + $j.firewall.status }
      if($j.registry  -and $j.registry.status)  { $parts += "reg=" + $j.registry.status }
      if($j.integrity -and $j.integrity.status) { $parts += "int=" + $j.integrity.status }

      $suffix = ""
      if($parts.Count -gt 0){ $suffix = " (" + ($parts -join ", ") + ")" }

      Write-Host ("[GFW] health=" + $overall + $suffix)
    }
  }
} catch {
  Write-Host "[GFW] health=ERROR"
}
}
  } catch {}
    if($out){
      Write-Host "[GFW] inner_output_begin"
      $out | ForEach-Object { Write-Host $_ }
      Write-Host "[GFW] inner_output_end"
    } else {
      Write-Host "[GFW] inner_output=(empty)"
    }
  } catch {}

  exit $code

}
catch {
  Write-Host "[GFW] Phase1 exception: $($_.Exception.Message)"
  exit 1
}
finally {
  if ($hasLock -and $null -ne $mutex) {
    try { $mutex.ReleaseMutex() } catch {}
  }
  if ($null -ne $mutex) {
    try { $mutex.Dispose() } catch {}
  }
}





.Exception.Message
        Start-Sleep -Milliseconds 200
      }
    }

    if(-not $ok -or $null -eq $j){
      if($lastErr){
        Write-Host ("[GFW] health=ERROR (parse): " + $lastErr)
      } else {
        Write-Host "[GFW] health=ERROR"
      }
    } else {
      $overall = [string]$j.overall
      if([string]::IsNullOrWhiteSpace($overall)){ $overall = "UNKNOWN" }

      $parts = @()
      if($j.firewall  -and $j.firewall.status)  { $parts += "fw="  + $j.firewall.status }
      if($j.registry  -and $j.registry.status)  { $parts += "reg=" + $j.registry.status }
      if($j.integrity -and $j.integrity.status) { $parts += "int=" + $j.integrity.status }

      $suffix = ""
      if($parts.Count -gt 0){ $suffix = " (" + ($parts -join ", ") + ")" }

      Write-Host ("[GFW] health=" + $overall + $suffix)
    }
  }
} catch {
  Write-Host ("[GFW] health=ERROR: " + # run-health-phase1.ps1
# GuardianFW – Phase 1 Health Wrapper (CLEAN)

$ErrorActionPreference = "Stop"
Set-StrictMode -Version Latest

# ---- Task trace ----
try {
  $ts = Get-Date -Format "yyyy-MM-dd HH:mm:ss.fff"
  Write-Host "[TASKTRACE] entered run-health-phase1.ps1 at $ts; user=$([Security.Principal.WindowsIdentity]::GetCurrent().Name)"
} catch {}

# ---- Mutex: prevent overlapping runs ----
$mutexName = "Local\GuardianFW_Health_Lock"
$mutex = $null
$hasLock = $false

try {
  try {
    $mutex = New-Object System.Threading.Mutex($false, $mutexName)
  } catch {
    $mutex = $null
  }

  if ($null -ne $mutex) {
    $hasLock = $mutex.WaitOne(5000)
  } else {
    $hasLock = $true
  }

  if (-not $hasLock) {
    Write-Host "[GFW] Health already running — NOOP"
    exit 0
  }

  # ---- Call inner health (authoritative) ----
  $inner = "C:\ProgramData\GuardianFW\engine\run-health.ps1"

  $out = @()
  $code = 0
  try {
    $out = & powershell.exe -NoProfile -ExecutionPolicy Bypass -File $inner 2>&1
    $code = $LASTEXITCODE
  } catch {
    $out += "[INNER_EXCEPTION] $($_.Exception.Message)"
    $code = 1
  }

  try {
    Write-Host "[GFW] inner_exit=$code"

  # ---- show latest evidence path (helps when inner is silent) ----
  try {
    $evRoot = "C:\ProgramData\GuardianFW\evidence"
    if(Test-Path $evRoot){
      $evLatest = Get-ChildItem $evRoot -Recurse -Filter "*.json" -EA SilentlyContinue |
        Sort-Object LastWriteTime -Descending | Select-Object -First 1
      if($evLatest){ Write-Host "[GFW] latest_evidence=$($evLatest.FullName)" }

# ---- tiny health summary line ----
try {
  $hl = Join-Path $evRoot "health\health-latest.json"

  if(!(Test-Path -LiteralPath $hl)){
    Write-Host "[GFW] health=NO_EVIDENCE"
  } else {

    $j = $null
    $ok = $false

    for($t=1; $t -le 8; $t++){
      try {
        $raw = Get-Content -LiteralPath $hl -Raw -Encoding UTF8 -ErrorAction Stop
        $j   = $raw | ConvertFrom-Json -ErrorAction Stop
        $ok = $true
        break
      } catch {
        Start-Sleep -Milliseconds 200
      }
    }

    if(-not $ok -or $null -eq $j){
      Write-Host "[GFW] health=ERROR"
    } else {
      $overall = [string]$j.overall
      if([string]::IsNullOrWhiteSpace($overall)){ $overall = "UNKNOWN" }

      $parts = @()
      if($j.firewall  -and $j.firewall.status)  { $parts += "fw="  + $j.firewall.status }
      if($j.registry  -and $j.registry.status)  { $parts += "reg=" + $j.registry.status }
      if($j.integrity -and $j.integrity.status) { $parts += "int=" + $j.integrity.status }

      $suffix = ""
      if($parts.Count -gt 0){ $suffix = " (" + ($parts -join ", ") + ")" }

      Write-Host ("[GFW] health=" + $overall + $suffix)
    }
  }
} catch {
  Write-Host "[GFW] health=ERROR"
}
}
  } catch {}
    if($out){
      Write-Host "[GFW] inner_output_begin"
      $out | ForEach-Object { Write-Host $_ }
      Write-Host "[GFW] inner_output_end"
    } else {
      Write-Host "[GFW] inner_output=(empty)"
    }
  } catch {}

  exit $code

}
catch {
  Write-Host "[GFW] Phase1 exception: $($_.Exception.Message)"
  exit 1
}
finally {
  if ($hasLock -and $null -ne $mutex) {
    try { $mutex.ReleaseMutex() } catch {}
  }
  if ($null -ne $mutex) {
    try { $mutex.Dispose() } catch {}
  }
}





.Exception.Message)
}
}

    if(-not $ok -or $null -eq $j){
      Write-Host "[GFW] health=ERROR"
    } else {
      $overall = [string]$j.overall
      if([string]::IsNullOrWhiteSpace($overall)){ $overall = "UNKNOWN" }

      $parts = @()
      if($j.firewall  -and $j.firewall.status)  { $parts += "fw="  + $j.firewall.status }
      if($j.registry  -and $j.registry.status)  { $parts += "reg=" + $j.registry.status }
      if($j.integrity -and $j.integrity.status) { $parts += "int=" + $j.integrity.status }

      $suffix = ""
      if($parts.Count -gt 0){ $suffix = " (" + ($parts -join ", ") + ")" }

      Write-Host ("[GFW] health=" + $overall + $suffix)
    }
  }
} catch {
  Write-Host "[GFW] health=ERROR"
}
}
  } catch {}
    if($out){
      Write-Host "[GFW] inner_output_begin"
      $out | ForEach-Object { Write-Host $_ }
      Write-Host "[GFW] inner_output_end"
    } else {
      Write-Host "[GFW] inner_output=(empty)"
    }
  } catch {}

  exit $code

}
catch {
  Write-Host "[GFW] Phase1 exception: $($_.Exception.Message)"
  exit 1
}
finally {
  if ($hasLock -and $null -ne $mutex) {
    try { $mutex.ReleaseMutex() } catch {}
  }
  if ($null -ne $mutex) {
    try { $mutex.Dispose() } catch {}
  }
}






