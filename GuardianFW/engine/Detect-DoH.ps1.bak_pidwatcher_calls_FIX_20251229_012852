param(
  [switch]$SelfTest,
  [switch]$KeepArtifacts,
  [int]$WindowSeconds = 6,
  [int]$WeakRepeatThreshold = 2
)

function Recover-PidFromTcpipByTcbPath([string]$tcpipTxtPath,[string]$tcb){
  try {
    if([string]::IsNullOrWhiteSpace($tcpipTxtPath) -or [string]::IsNullOrWhiteSpace($tcb)){ return 0 }
    if(-not (Test-Path -LiteralPath $tcpipTxtPath)){ return 0 }

    # Find first occurrence of the TCB token
    $mi = Select-String -LiteralPath $tcpipTxtPath -Pattern ([regex]::Escape($tcb)) -EA SilentlyContinue | Select-Object -First 1
    if($null -eq $mi){ return 0 }

    $ln = 0
    try { $ln = [int]$mi.LineNumber } catch { $ln = 0 }
    if($ln -le 0){ $ln = 1 }

    # Load file once (text size is a few MB; OK), then scan forward from the hit line
    $lines = Get-Content -LiteralPath $tcpipTxtPath -Encoding UTF8 -EA SilentlyContinue
    if(-not $lines){ return 0 }

    $startIdx = [Math]::Max(0, $ln - 1)
    $blockLines = $lines | Select-Object -Skip $startIdx -First 900
    $block = ($blockLines -join "`n")

    # Return the FIRST non-zero PID found in the forward window
    foreach($mm in [regex]::Matches($block,"(?im)\bPID\s*=\s*(\d+)\b")){
      try { $v = [int]$mm.Groups[1].Value; if($v -gt 0){ return $v } } catch {}
    }
    foreach($mm in [regex]::Matches($block,"(?im)\bPID=(\d+)\b")){
      try { $v = [int]$mm.Groups[1].Value; if($v -gt 0){ return $v } } catch {}
    }

    return 0
  } catch {
    return 0
  }
}



$ErrorActionPreference="Stop"
Set-StrictMode -Version Latest



function Start-PidMapTrace([string]$TraceName,[string]$OutEtl){
  # Kernel process provider: process start/stop gives us ImageFileName + PID
  # "PROC_THREAD" kernel keyword is enough for process events
  & logman.exe stop $TraceName -ets 2>$null | Out-Null
  & logman.exe delete $TraceName 2>$null | Out-Null

  & logman.exe create trace $TraceName -ets -o $OutEtl -nb 16 64 -bs 1024 -mode Circular -f bincirc -max 32 | Out-Null
  & logman.exe update trace $TraceName -ets -p "Microsoft-Windows-Kernel-Process" 0x10 0x5 | Out-Null
  # 0x10 = Process keyword
  & logman.exe start $TraceName -ets | Out-Null
}

function Stop-PidMapTrace([string]$TraceName){
  & logman.exe stop $TraceName -ets 2>$null | Out-Null
}

function Build-PidMapFromEtl([string]$EtlPath){
  # Returns Hashtable: PID -> ImageFileName
  $map = @{}
  if(!(Test-Path -LiteralPath $EtlPath)){ return $map }

  # Convert ETL to text with tracerpt (fast enough for small circular buffer)
  $tmp = Join-Path $env:TEMP ("pidmap_{0}.csv" -f ([guid]::NewGuid().ToString("N")))
  # tracerpt can fail if ETL not finalized yet -> retry a few times
$ok = $false
for($i=1; $i -le 5; $i++){
  try {
    & tracerpt.exe $EtlPath -o $tmp -of CSV 2>$null | Out-Null
    if(Test-Path -LiteralPath $tmp){ $ok = $true; break }
  } catch {}
  Start-Sleep -Milliseconds 250
}
if(-not $ok){ return $map }

  if(!(Test-Path -LiteralPath $tmp)){ return $map }

  # CSV contains rows with "Process/Start" and columns include "Process ID" and "Image File Name" (varies by OS)
  $rows = Import-Csv -LiteralPath $tmp
  foreach($r in $rows){
    try {
      $evt = ($r."Event Name")
      if($evt -and $evt -match 'Process/Start'){
        $procId = $r."Process ID"
        $img = $r."Image File Name"
        if($procId -and $img){
          $pidInt = [int]$procId
          if(-not $map.ContainsKey($pidInt)){
            $map[$pidInt] = $img
          }
        }
      }
    } catch {}
  }

  try { Remove-Item -LiteralPath $tmp -Force -EA SilentlyContinue | Out-Null } catch {}
  return $map
}
$dohIps = @("1.1.1.1","1.0.0.1","8.8.8.8","8.8.4.4","9.9.9.9","149.112.112.112")

$eventsDir = "C:\ProgramData\GuardianFW\events"
New-Item -ItemType Directory -Path $eventsDir -Force | Out-Null
$logPath   = Join-Path $eventsDir "doh-detect.jsonl"
$statePath = Join-Path $eventsDir "doh-detect.state.json"

$etl = Join-Path $eventsDir "tcpip_doh.etl"
$txt = Join-Path $eventsDir "tcpip_doh.txt"

function Stop-TraceQuiet { try { netsh trace stop | Out-Null } catch {} }

function Load-State {
  if(Test-Path $statePath){
    try { return (Get-Content -LiteralPath $statePath -Raw -EA SilentlyContinue | ConvertFrom-Json) } catch {}
  }
  return [pscustomobject]@{ weak_hits = @() }
}

function Save-State($state){
  try { $state | ConvertTo-Json -Compress | Set-Content -LiteralPath $statePath -Encoding UTF8 -Force } catch {}
}

function Add-EventLog($obj){
  try {
    ($obj | ConvertTo-Json -Compress) | Add-Content -LiteralPath $logPath -Encoding UTF8
  } catch {}
}

function Extract-PidFromText([string]$s){
  if([string]::IsNullOrWhiteSpace($s)){ return 0 }

  try {
    # Return the FIRST non-zero PID found (PID=0 appears often before the real PID)
    foreach($m in [regex]::Matches($s,'(?im)\bPID\s*=\s*(\d+)\b')){
      try { $v = [int]$m.Groups[1].Value; if($v -gt 0){ return $v } } catch {}
    }
    foreach($m in [regex]::Matches($s,'(?im)\bPID=(\d+)\b')){
      try { $v = [int]$m.Groups[1].Value; if($v -gt 0){ return $v } } catch {}
    }
  } catch {}

  return 0
}

function Get-HitText($h){
  try {
    if($null -eq $h){ return "" }

    # Try common fields (hashtable or object)
    foreach($k in @("blk","block","text","raw","line","message","ctx","context")){
      try {
        if($h -is [hashtable]){
          if($h.ContainsKey($k) -and $h[$k]){ return [string]$h[$k] }
        } else {
          $v = $h.$k
          if($v){ return [string]$v }
        }
      } catch {}
    }

    # Try common array-of-lines fields
    foreach($k in @("lines","ctxLines","contextLines","blockLines")){
      try {
        if($h -is [hashtable]){
          if($h.ContainsKey($k) -and $h[$k]){ return (($h[$k]) -join "`n") }
        } else {
          $v = $h.$k
          if($v){ return ($v -join "`n") }
        }
      } catch {}
    }
  } catch {}
  return ""
}



function Proc-Name([int]$procId, [hashtable]$PidMap){
  if($procId -le 0){ return "unknown" }

  # 0) Use PID map if available (most reliable for short-lived processes like curl)
  try {
    if($null -ne $PidMap -and $PidMap.ContainsKey($procId)){
      $x = [string]$PidMap[$procId]
      if($x -and $x.Trim()){ return $x }
    }
  } catch {}

  # 1) Try CIM
  try {
    $w = Get-CimInstance Win32_Process -Filter "ProcessId=$procId" -ErrorAction Stop
    if($null -ne $w -and $w.Name -and $w.Name.Trim()){
      return $w.Name
    }
  } catch {}

  # 2) Fallback: Get-Process
  try {
    $p = Get-Process -Id $procId -ErrorAction Stop
    if($null -ne $p -and $p.ProcessName -and $p.ProcessName.Trim()){
      return $p.ProcessName
    }
  } catch {}

  return "unknown"
}


# --- PID map snapshot (best-effort) ---
$script:PidMap = @{}

function Refresh-PidMap(){
  try {
    # MERGE into existing map (keep last-known names for short-lived PIDs)
    foreach($p in Get-Process -ErrorAction SilentlyContinue){
      try {
        $id = [int]$p.Id
        if($id -gt 0){
          $n = [string]$p.ProcessName
          if($n){
            if(-not $n.EndsWith(".exe",[System.StringComparison]::OrdinalIgnoreCase)){ $n = $n + ".exe" }
            $script:PidMap[$id] = $n
          }
        }
      } catch {}
    }
  } catch {}
}


function Start-PidWatcher(){
  try {
    # Don't double-register
    if(Get-EventSubscriber -SourceIdentifier "GuardianFW-PidStart" -ErrorAction SilentlyContinue){ return }

    Register-WmiEvent -Query "SELECT ProcessID, ProcessName FROM Win32_ProcessStartTrace" `
      -SourceIdentifier "GuardianFW-PidStart" -Action {
        try {
          $id = [int]$Event.SourceEventArgs.NewEvent.ProcessID
          $n  = [string]$Event.SourceEventArgs.NewEvent.ProcessName
          if($id -gt 0 -and $n){
            if(-not $n.EndsWith(".exe",[System.StringComparison]::OrdinalIgnoreCase)){ $n = $n + ".exe" }
            $script:PidMap[$id] = $n
          }
        } catch {}
      } | Out-Null
  } catch {}
}

function Stop-PidWatcher(){
  try {
    Unregister-Event -SourceIdentifier "GuardianFW-PidStart" -ErrorAction SilentlyContinue | Out-Null
    Remove-Event    -SourceIdentifier "GuardianFW-PidStart" -ErrorAction SilentlyContinue | Out-Null
  } catch {}
}
# initial snapshot
Refresh-PidMap
# ---- capture ----
Stop-TraceQuiet
try { Remove-Item $etl,$txt -Force -EA SilentlyContinue | Out-Null } catch {}

try {
  netsh trace start capture=no report=no tracefile="$etl" provider=Microsoft-Windows-TCPIP level=5 keywords=0xFFFFFFFF | Out-Null

  if($SelfTest){
    Start-Sleep -Milliseconds 200
    $u="https://cloudflare-dns.com/dns-query?name=example.com&type=A"
    curl.exe -s --http1.1 "$u" --resolve cloudflare-dns.com:443:1.1.1.1 -H "accept: application/dns-json" | Out-Null
  }

  Start-Sleep -Seconds $WindowSeconds
}
finally {
  Stop-TraceQuiet
}

netsh trace convert input="$etl" output="$txt" | Out-Null

$blob = ""
try { $blob = Get-Content -LiteralPath $txt -Raw -EA SilentlyContinue } catch {}

if(-not $blob){
  if(-not $KeepArtifacts){ try { Remove-Item $etl,$txt -Force -EA SilentlyContinue | Out-Null } catch {} }
  exit 0
}

# ---- robust parsing ----
# Strategy: find blocks containing remote=<ip>:443 and then classify by keywords found nearby.
# We grab up to 600 chars after the remote match, so line wrapping/order doesn't matter.
$hits = @()
$weakSeen = @()

foreach($ip in $dohIps){
  $reBlock = [regex]("(?is)(?:remote|Remote)\s*=\s*"+[regex]::Escape($ip)+":443\)(.{0,600})")
  foreach($m in $reBlock.Matches($blob)){
    $procId = 0  # StrictMode: always define before use
    $tail = $m.Groups[1].Value


    # Build a BIG context window around the match index:
    # - include BEFORE the "remote=..." so we capture "Tcb 0x...."
    # - include FAR AFTER so we capture "shutdown initiated ... PID = ####"
    $ctxStart = [Math]::Max(0, $m.Index - 800)
    $ctxLen   = [Math]::Min($blob.Length - $ctxStart, 9000)
    $blkText  = $blob.Substring($ctxStart, $ctxLen)
    # event type detection (wrap-safe)
    $isStrong = ($tail -match '(?is)connect\s+completed')
    $isMed    = ($tail -match '(?is)requested\s+to\s+connect|connect\s+proceeding')
    $isWeak   = ($tail -match '(?is)\bexists\.')

    if(-not ($isStrong -or $isMed -or $isWeak)){ continue }

    # PID anywhere in the block tail (or shortly after)

    $strength = if($isStrong){"strong"} elseif($isMed){"medium"} else {"weak"}
    $source   = if($isStrong){"etw_tcpip_connect_completed"}
                elseif($isMed){"etw_tcpip_preconnect"}
                else {"etw_tcpip_exists_state"}
    # --- unified PID extraction (authoritative) ---
    # Build a reliable block from the regex Match + tail window
    $blkText = ""
    try {
      if($tail){ $blkText = $blkText + "`n" + $tail }
    } catch {
      $blkText = [string]$tail
    }

    # 1) Direct PID extraction from the block (often catches: "PID = ####")
    $procId = Extract-PidFromText $blkText

    # 2) If preconnect/connect-failed shows PID=0, recover via TCB correlation
    if($procId -le 0){
      try {
        $tcb = ""
        $mt = [regex]::Match($blkText,"(?im)\bTcb\s+(0x[0-9A-Fa-f]+)\b")
        if($mt.Success){ $tcb = $mt.Groups[1].Value }

        if([string]::IsNullOrWhiteSpace($tcb)){
          $mt2 = [regex]::Match($blkText,"(?im)\bconnection\s+(0x[0-9A-Fa-f]+)\b")
          if($mt2.Success){ $tcb = $mt2.Groups[1].Value }
        }

        if(-not [string]::IsNullOrWhiteSpace($tcb)){
          $tcpipPath = $txt
          $r = Recover-PidFromTcpipByTcbPath -tcpipTxtPath $txt -tcb $tcb
          if($r -gt 0){ $procId = $r }
        }
      } catch {}
    }

    # Leave proc blank here; it will be filled later using the PID map (most reliable for short-lived curl)
    $proc = ""
    # Best practice: resolve proc name from PID safely + "learn" it into the PID map.
    if($procId -gt 0){
      try {
        $pn = "unknown"

        # 1) Try existing PID map first (may contain last-known names)
        try {
          if($script:PidMap -and $script:PidMap.ContainsKey($procId)){
            $pn = [string]$script:PidMap[$procId]
          }
        } catch {}

        # 2) If still unknown, refresh snapshot + try again
        if($pn -eq "unknown"){
          try { Refresh-PidMap } catch {}
          try {
            if($script:PidMap -and $script:PidMap.ContainsKey($procId)){
              $pn = [string]$script:PidMap[$procId]
            }
          } catch {}
        }

        # 3) Fallback: direct lookup (may fail if process already exited)
        if($pn -eq "unknown"){
          try {
            $p = Get-Process -Id $procId -ErrorAction Stop
            $pn = [string]$p.ProcessName
            if($pn -and (-not $pn.EndsWith(".exe",[System.StringComparison]::OrdinalIgnoreCase))){
              $pn = $pn + ".exe"
            }
          } catch {}
        }

        # 4) If we got a name, store it to PID map for later events (sticky)
        if(-not [string]::IsNullOrWhiteSpace($pn) -and $pn -ne "unknown"){
          $proc = $pn
          try { $script:PidMap[$procId] = $pn } catch {}
        }
      } catch {}
    }

    $obj = [pscustomobject]@{
      ts       = (Get-Date).ToString("s")
      remote   = $ip
      port     = 443
    pid = $procId
      proc     = $proc
      strength = $strength
      source   = $source
    }

    $hits += $obj
    if($strength -eq "weak"){ $weakSeen += $ip }
  }
}

# Deduplicate hits (remote+pid+strength)
$hits = $hits | Sort-Object remote,pid,strength -Unique
# ---- Stop PID map trace + build PID->Image map ----
try { Stop-PidMapTrace -TraceName $PidTraceName } catch {}
try { $PidMap = Build-PidMapFromEtl -EtlPath $PidEtl } catch { $PidMap = @{} }

# Fill missing proc names (avoid "proc": null)
foreach($h in $hits){
  try {
    if($null -eq $h.proc -or [string]::IsNullOrWhiteSpace([string]$h.proc)){
      $h.proc = (Proc-Name $h.pid $PidMap)
      if([string]::IsNullOrWhiteSpace([string]$h.proc)){ $h.proc = "unknown" }
    }
  } catch {
    try { $h.proc = "unknown" } catch {}
  }
}

# Optional cleanup
if(-not $KeepArtifacts){
  try { Remove-Item $etl,$txt -Force -EA SilentlyContinue | Out-Null } catch {}
}

# ---- Decision Logic ----
# strong/medium => immediate suspicious
if($hits | Where-Object { $_.strength -in @("strong","medium") }){
  foreach($h in $hits){ Add-EventLog $h }
  exit 20
}

# weak-only => require repeats within window
  $hits = @($hits)  # force array (safe under StrictMode)
if($hits.Count -gt 0){
  $state = Load-State
  $now = Get-Date
  $cut = $now.AddSeconds(-1 * $WeakRepeatWindowSeconds)

  $recent = @()
  foreach($w in $state.weak_hits){
    try { if([datetime]$w.ts -ge $cut){ $recent += $w } } catch {}
  }

  foreach($rip in ($weakSeen | Select-Object -Unique)){
    $recent += [pscustomobject]@{ ts = $now.ToString("o"); remote = $rip }
  }

  $state.weak_hits = $recent
  Save-State $state

  foreach($rip in ($weakSeen | Select-Object -Unique)){
    $count = @($state.weak_hits | Where-Object { $_.remote -eq $rip }).Count
    if($count -ge $WeakRepeatThreshold){
      foreach($h in $hits){ Add-EventLog $h }
      exit 20
    }
  }

  # weak seen but not enough repeats => log and exit clean
  foreach($h in $hits){ Add-EventLog $h }
  exit 0
}

exit 0


































