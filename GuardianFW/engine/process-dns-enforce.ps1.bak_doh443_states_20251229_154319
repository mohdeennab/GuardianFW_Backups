Set-StrictMode -Version Latest
$ErrorActionPreference="Stop"

$Root="C:\ProgramData\GuardianFW"
$Policy=Join-Path $Root "policy\policy.json"
$DohIps=Join-Path $Root "policy\doh-ips.json"
$Audit=Join-Path $Root "logs\guardian-audit.jsonl"
$Fail =Join-Path $Root "sealed\FAIL_SECURE.flag"

function Write-Audit([string]$event,[hashtable]$data=@{}) {
  $dir = Split-Path $Audit
  if(!(Test-Path $dir)){ New-Item -ItemType Directory -Path $dir -Force | Out-Null }
  $rec=[pscustomobject]@{ tsUtc=(Get-Date).ToUniversalTime().ToString("o"); event=$event; data=$data }
  ($rec|ConvertTo-Json -Compress -Depth 12) | Add-Content -LiteralPath $Audit -Encoding UTF8
}

function HasProp($o,[string]$n){ return ($o -and $o.PSObject.Properties.Match($n).Count -gt 0) }

function Safe-LoadJson([string]$path){
  try { return (Get-Content -LiteralPath $path -Raw -Encoding UTF8 | ConvertFrom-Json) }
  catch { Write-Audit "json_load_failed" @{path=$path; error=$_.Exception.Message}; return $null }
}

# -------------------------
# Load policy
# -------------------------
$cfg = Safe-LoadJson $Policy
if($null -eq $cfg){ exit 0 }

if(-not (HasProp $cfg "process_dns_policy")){
  Write-Audit "process_dns_policy_missing" @{}
  exit 0
}

$pdp = $cfg.process_dns_policy
$mode="monitor"; $action="log"
if(HasProp $pdp "mode"){ $mode=[string]$pdp.mode }
if(HasProp $pdp "action"){ $action=[string]$pdp.action }

$rules=@()
if(HasProp $pdp "allow" -and $pdp.allow){ $rules=@($pdp.allow) }

function Is-AllowedImage([string]$img){
  foreach($r in $rules){
    if($r -and (HasProp $r "image") -and $r.image){
      if($img -ieq [string]$r.image){ return $true }
    }
  }
  return $false
}

# -------------------------
# Load DoH IP list (optional)
# -------------------------
$dohSet = @{}
$doh = Safe-LoadJson $DohIps
if($doh -and (HasProp $doh "providers") -and $doh.providers){
  foreach($prov in @($doh.providers)){
    if($prov -and (HasProp $prov "ips") -and $prov.ips){
      $pname = $null
      if(HasProp $prov "name"){ $pname = [string]$prov.name }
      foreach($ip in @($prov.ips)){
        if($ip){
          $dohSet[[string]$ip] = $pname
        }
      }
    }
  }
}

# -------------------------
# DNS53 detection:
# - UDP: LocalPort == 53
# - TCP: RemotePort == 53
# -------------------------
$udp = Get-NetUDPEndpoint -ErrorAction SilentlyContinue | Where-Object { $_.LocalPort -eq 53 }
foreach($u in $udp){
  $ProcId=[int]$u.OwningProcess
  if($ProcId -le 4){ continue }

  $p = Get-Process -Id $ProcId -ErrorAction SilentlyContinue
  if(!$p -or -not $p.Path){ continue }
  $img=[string]$p.Path

  if(-not (Is-AllowedImage $img)){
    Write-Audit "process_dns_violation" @{
      kind="dns53_udp"; pid=$ProcId; image=$img;
      local=$u.LocalAddress; lport=$u.LocalPort;
      mode=$mode; action=$action
    }

    if($mode -ieq "enforce" -and $action -ieq "kill"){
      try { Stop-Process -Id $ProcId -Force; Write-Audit "process_dns_killed" @{kind="dns53_udp"; pid=$ProcId; image=$img} }
      catch { Write-Audit "process_dns_kill_failed" @{kind="dns53_udp"; pid=$ProcId; image=$img; error=$_.Exception.Message}; New-Item -ItemType File -Path $Fail -Force | Out-Null }
    }
  }
}

$tcp53 = Get-NetTCPConnection -State Established -ErrorAction SilentlyContinue | Where-Object { $_.RemotePort -eq 53 }
foreach($c in $tcp53){
  $ProcId=[int]$c.OwningProcess
  if($ProcId -le 4){ continue }

  $p = Get-Process -Id $ProcId -ErrorAction SilentlyContinue
  if(!$p -or -not $p.Path){ continue }
  $img=[string]$p.Path

  if(-not (Is-AllowedImage $img)){
    Write-Audit "process_dns_violation" @{
      kind="dns53_tcp"; pid=$ProcId; image=$img; remote=$c.RemoteAddress; port=$c.RemotePort;
      mode=$mode; action=$action
    }

    if($mode -ieq "enforce" -and $action -ieq "kill"){
      try { Stop-Process -Id $ProcId -Force; Write-Audit "process_dns_killed" @{kind="dns53_tcp"; pid=$ProcId; image=$img} }
      catch { Write-Audit "process_dns_kill_failed" @{kind="dns53_tcp"; pid=$ProcId; image=$img; error=$_.Exception.Message}; New-Item -ItemType File -Path $Fail -Force | Out-Null }
    }
  }
}

# -------------------------
# DoH IP correlation (SAFE):
# - TCP 443 only if RemoteAddress is in doh-ips.json
# -------------------------
if($dohSet.Count -gt 0){
  $tcp443 = Get-NetTCPConnection -State Established -ErrorAction SilentlyContinue | Where-Object { $_.RemotePort -eq 443 }
  foreach($c in $tcp443){
    $rip = [string]$c.RemoteAddress
    if(-not $rip){ continue }
    if(-not $dohSet.ContainsKey($rip)){ continue }

    $ProcId=[int]$c.OwningProcess
    if($ProcId -le 4){ continue }

    $p = Get-Process -Id $ProcId -ErrorAction SilentlyContinue
    $img = $null
    if($p -and $p.Path){ $img = [string]$p.Path }

    $provider = $dohSet[$rip]

    Write-Audit "process_dns_violation" @{
      kind="doh_ip_hit"; pid=$ProcId; image=$img; remote=$rip; port=443; provider=$provider;
      mode=$mode; action=$action
    }

    # Optional console visibility when manually running
    Write-Host ("DoH hit: {0} {1} {2}" -f $provider, $rip, $img)

    if($mode -ieq "enforce" -and $action -ieq "kill"){
      try { Stop-Process -Id $ProcId -Force; Write-Audit "process_dns_killed" @{kind="doh_ip_hit"; pid=$ProcId; image=$img; remote=$rip; provider=$provider} }
      catch { Write-Audit "process_dns_kill_failed" @{kind="doh_ip_hit"; pid=$ProcId; image=$img; remote=$rip; provider=$provider; error=$_.Exception.Message}; New-Item -ItemType File -Path $Fail -Force | Out-Null }
    }
  }
}

# -------------------------
# DEBUG: observe 443 remotes (always)
# -------------------------
try {
  $tcp443all = Get-NetTCPConnection -State Established -ErrorAction SilentlyContinue | Where-Object { $_.RemotePort -eq 443 }
  foreach($c in $tcp443all){
    $ProcId=[int]$c.OwningProcess
    if($ProcId -le 4){ continue }

    $p = Get-Process -Id $ProcId -ErrorAction SilentlyContinue
    $img=$null
    if($p -and $p.Path){ $img=[string]$p.Path }

    $rip=[string]$c.RemoteAddress
    if(-not $rip){ continue }

    $prov=$null
    if($dohSet.Count -gt 0 -and $dohSet.ContainsKey($rip)){ $prov=$dohSet[$rip] }

    Write-Audit "tcp443_seen" @{ pid=$ProcId; image=$img; remote=$rip; provider=$prov }
  }
} catch {
  Write-Audit "tcp443_seen_failed" @{ error=$_.Exception.Message }
}

# If you run manually and want window to stay: set env var before running:
#   setx GUARDIANFW_PAUSE 1
if($Host.Name -match "ConsoleHost" -and $env:GUARDIANFW_PAUSE -eq "1"){
  Read-Host "Press Enter" | Out-Null
}

exit 0
