# --- Single-instance guard (mutex) ---
$mutexName = "Global\GuardianFW-ProcessDNS"
$mutex = New-Object System.Threading.Mutex($false, $mutexName)
$hasLock = $false
try {
  $hasLock = $mutex.WaitOne(0)
  if(-not $hasLock){ exit 0 }

Set-StrictMode -Version Latest
$ErrorActionPreference="Stop"

$Root="C:\ProgramData\GuardianFW"
$Policy=Join-Path $Root "policy\policy.json"
$DohIps=Join-Path $Root "policy\doh-ips.json"
$Audit=Join-Path $Root "logs\guardian-audit.jsonl"
$Fail =Join-Path $Root "sealed\FAIL_SECURE.flag"

function Write-Audit([string]$event,[hashtable]$data=@{}) {

  # normalize
  $ev = ([string]$event).Trim().ToLowerInvariant()

  $dir = Split-Path $Audit
  if(!(Test-Path $dir)){ New-Item -ItemType Directory -Path $dir -Force | Out-Null }

  # ---- helpers (robust for hashtable / IDictionary / PSCustomObject) ----
  function _GetProp($obj,[string]$k){
    try{
      if($null -eq $obj){ return $null }
      if($obj -is [System.Collections.IDictionary]){
        if($obj.Contains($k)){ return $obj[$k] }
        if($obj.Contains($k.ToLowerInvariant())){ return $obj[$k.ToLowerInvariant()] }
        if($obj.Contains($k.ToUpperInvariant())){ return $obj[$k.ToUpperInvariant()] }
        return $null
      }
      $p = $obj.PSObject.Properties[$k]
      if($p){ return $p.Value }
      $p = $obj.PSObject.Properties[$k.ToLowerInvariant()]
      if($p){ return $p.Value }
      $p = $obj.PSObject.Properties[$k.ToUpperInvariant()]
      if($p){ return $p.Value }
      return $null
    } catch { return $null }
  }

  function _SetProp($obj,[string]$k,$v){
    try{
      if($null -eq $obj){ return }
      if($obj -is [System.Collections.IDictionary]){
        if($obj.Contains($k)){ $obj[$k] = $v; return }
        if($obj.Contains($k.ToLowerInvariant())){ $obj[$k.ToLowerInvariant()] = $v; return }
        if($obj.Contains($k.ToUpperInvariant())){ $obj[$k.ToUpperInvariant()] = $v; return }
        # if no key exists, set standard key
        $obj[$k] = $v
        return
      }
      $p = $obj.PSObject.Properties[$k]
      if($p){ $p.Value = $v; return }
      # add property if missing
      $obj | Add-Member -NotePropertyName $k -NotePropertyValue $v -Force
    } catch { }
  }

  # ---- IMPORTANT: Drop 4104 ScriptBlock chunk spam BEFORE writing anything ----
  if($ev -eq "lolbin_detected"){
    $m = _GetProp $data "message"
    if($null -eq $m){ $m = _GetProp $data "Message" }
    $msg = if($null -ne $m){ [string]$m } else { "" }

    if($msg -match '(?i)^\s*Creating\s+Scriptblock\s+text\s*\(' -or
       $msg -match '(?i)\beventId\s*=\s*4104\b' -or
       $msg -match '(?i)\bScriptBlock\s+ID\b' -or
       $msg -match '(?i)\bCmdletization\b'){
      return
    }

    # also catch cases where the spam appears elsewhere
    $blob = ""
    try { $blob = ($data | ConvertTo-Json -Compress -Depth 8) } catch { $blob = "" }
    if($blob -match '(?i)Creating\s+Scriptblock\s+text\s*\(' -or
       $blob -match '(?i)\beventId\s*=\s*4104\b' -or
       $blob -match '(?i)\bScriptBlock\s+ID\b' -or
       $blob -match '(?i)\bCmdletization\b'){
      return
    }
  }

  # ---- Compact huge events (robust) ----
  if($ev -eq "lolbin_detected"){
    $m = _GetProp $data "message"
    if($null -eq $m){ $m = _GetProp $data "Message" }
    if($null -ne $m){
      $s = [string]$m
      if($s.Length -gt 600){
        _SetProp $data "message" ($s.Substring(0,600) + "...(truncated)")
      }
    }
  }

  # ---- Rate limit noisy duplicates (hash key) ----
  $stateDir  = Join-Path $Root "state"
  $stateFile = Join-Path $stateDir "audit-rate.json"
  if(!(Test-Path $stateDir)){ New-Item -ItemType Directory -Path $stateDir -Force | Out-Null }

  function To-PlainHashtable($obj){
    $h = @{}
    if($null -eq $obj){ return $h }
    if($obj -is [hashtable]){
      foreach($k in $obj.Keys){
        $v = $obj[$k]
        $h[[string]$k] = if($null -eq $v){ "" } else { [string]$v }
      }
      return $h
    }
    foreach($p in $obj.PSObject.Properties){
      $name = [string]$p.Name
      $val  = $p.Value
      $h[$name] = if($null -eq $val){ "" } else { [string]$val }
    }
    return $h
  }

  function Get-StableKey([string]$ev2, $d){
    if([string]::IsNullOrWhiteSpace($ev2)){ return $null }
    $ev3 = ([string]$ev2).Trim().ToLowerInvariant()

    if($ev3 -notin @("tcp443_seen","lolbin_detected","dns_decision","doh_blocked","dns_blocked","dns_allowed","enforce_decision")){
      return $null
    }

    $h = To-PlainHashtable $d
    if($h.Count -eq 0){ return $null }

    $pairs = New-Object System.Collections.Generic.List[string]

    if($ev3 -eq "tcp443_seen"){
      $pid = if($h.ContainsKey("pid")){ $h["pid"] } else { "" }
      $rem = if($h.ContainsKey("remote")){ $h["remote"] } else { "" }
      $img = if($h.ContainsKey("image")){ $h["image"] } else { "" }
      $pairs.Add("pid=$pid"); $pairs.Add("remote=$rem"); $pairs.Add("image=$img")
    }
    elseif($ev3 -eq "lolbin_detected"){
      $eid  = if($h.ContainsKey("eventId")){ $h["eventId"] } else { "" }
      $sbid = ""
      if($h.ContainsKey("ScriptBlockId")){ $sbid = $h["ScriptBlockId"] }
      if([string]::IsNullOrWhiteSpace($sbid) -and $h.ContainsKey("scriptblockid")){ $sbid = $h["scriptblockid"] }
      $pairs.Add("eventid=$eid"); $pairs.Add("sbid=$sbid")
    }
    else {
      foreach($k in ($h.Keys | Sort-Object)){
        $v = $h[$k]
        if($null -eq $v){ $v = "" }
        $pairs.Add(("{0}={1}" -f $k.ToLowerInvariant(), ($v.ToString().Trim())))
      }
    }

    $payload = $ev3 + "|" + ($pairs -join "|")

    $sha = [System.Security.Cryptography.SHA256]::Create()
    try{
      $bytes = [System.Text.Encoding]::UTF8.GetBytes($payload)
      $hash  = $sha.ComputeHash($bytes)
      return (-join ($hash | ForEach-Object { # --- Single-instance guard (mutex) ---
$mutexName = "Global\GuardianFW-ProcessDNS"
$mutex = New-Object System.Threading.Mutex($false, $mutexName)
$hasLock = $false
try {
  $hasLock = $mutex.WaitOne(0)
  if(-not $hasLock){ exit 0 }

Set-StrictMode -Version Latest
$ErrorActionPreference="Stop"

$Root="C:\ProgramData\GuardianFW"
$Policy=Join-Path $Root "policy\policy.json"
$DohIps=Join-Path $Root "policy\doh-ips.json"
$Audit=Join-Path $Root "logs\guardian-audit.jsonl"
$Fail =Join-Path $Root "sealed\FAIL_SECURE.flag"

function Write-Audit([string]$event,[hashtable]$data=@{}) {
  $dir = Split-Path $Audit
  if(!(Test-Path $dir)){ New-Item -ItemType Directory -Path $dir -Force | Out-Null }

  # ---- Compact huge events ----
  # ---- Drop noisy PowerShell ScriptBlock (4104) chunk spam mislabeled as lolbin ----
  # Enterprise-robust: the “Creating Scriptblock text …” spam may be in Message/message or elsewhere in $data.
  if($event -eq "lolbin_detected" -and $null -ne $data){
    $blob = ""
    try {
      # stringify entire data (handles hashtable, PSCustomObject, ordered dictionary, etc.)
      $blob = ($data | ConvertTo-Json -Compress -Depth 8)
    } catch {
      try { $blob = [string]$data } catch { $blob = "" }
    }

    if($blob -match '(?i)Creating\s+Scriptblock\s+text\s*\(' -or
       $blob -match '(?i)\beventId\s*=\s*4104\b' -or
       $blob -match '(?i)\bScriptBlock\s+ID\b' -or
       $blob -match '(?i)\bCmdletization\b'){
      return
    }
  }



  # ---- GuardianFW self-whitelist ----
  # If GuardianFW triggers ScriptBlock/PowerShell noise that gets labeled as lolbin_detected,
  # ignore it (prevents self-noise in enterprise telemetry).
  if($event -eq "lolbin_detected" -and $data -is [hashtable]){
    $msg = ""
    if($data.ContainsKey("message")){ $msg = [string]$data["message"] }

    $selfNeedles = @(
      "C:\ProgramData\GuardianFW\",
      "\ProgramData\GuardianFW\",
      "\GuardianFW\engine\",
      "process-dns-enforce.ps1",
      "GuardianFW-ProcessDNS",
      "GuardianControl",
      "GuardianAgent"
    )

    foreach($n in $selfNeedles){
      if($msg -like "*$n*"){ return }
    }

    # If later you add structured fields, honor them too
    if($data.ContainsKey("image") -and ([string]$data["image"] -like "*\GuardianFW\*")){ return }
  }
  # ---- Drop noisy PowerShell ScriptBlock (4104) chunk spam mislabeled as lolbin ----
  # Enterprise-robust: the “Creating Scriptblock text …” spam may be in Message/message or elsewhere in $data.
  if($event -eq "lolbin_detected" -and $null -ne $data){
    $blob = ""
    try {
      # stringify entire data (handles hashtable, PSCustomObject, ordered dictionary, etc.)
      $blob = ($data | ConvertTo-Json -Compress -Depth 8)
    } catch {
      try { $blob = [string]$data } catch { $blob = "" }
    }

    if($blob -match '(?i)Creating\s+Scriptblock\s+text\s*\(' -or
       $blob -match '(?i)\beventId\s*=\s*4104\b' -or
       $blob -match '(?i)\bScriptBlock\s+ID\b' -or
       $blob -match '(?i)\bCmdletization\b'){
      return
    }
  }


  # ---- Ignore GuardianFW self-activity ----
  if($event -eq "lolbin_detected" -and $data -is [hashtable]){
    $msg = ""
    if($data.ContainsKey("message")){ $msg = [string]$data["message"] }

    # Indicators that this is our own engine/services doing PowerShell work
    $selfHits = @(
      "C:\ProgramData\GuardianFW\",
      "\GuardianFW\",
      "GuardianFW-ProcessDNS",
      "process-dns-enforce.ps1",
      "GuardianAgent",
      "GuardianControl"
    )

    foreach($s in $selfHits){
      if($msg -like "*$s*"){ return }
    }

    # If in future you add structured fields, honor them too
    if($data.ContainsKey("image") -and ([string]$data["image"] -like "*GuardianFW*")){ return }
  }

  if($event -eq "lolbin_detected" -and $data -is [hashtable] -and $data.ContainsKey("message")){
    $msg = [string]$data["message"]
    # common 4104 chunk patterns
    if($msg -match '(?i)Creating Scriptblock text\s*\(' -or
       $msg -match '(?i)\beventId\s*=\s*4104\b' -or
       $msg -match '(?i)\bScriptBlock ID\b'){
      return
    }
  }

  if($event -eq "lolbin_detected" -and $data -is [hashtable] -and $data.ContainsKey("message")){
    $m = [string]$data["message"]
    if($m.Length -gt 600){ $data["message"] = $m.Substring(0,600) + "...(truncated)" }
  }

  # ---- Rate limit noisy duplicates (robust hashed key) ----
  $stateDir  = Join-Path $Root "state"
  $stateFile = Join-Path $stateDir "audit-rate.json"
  if(!(Test-Path $stateDir)){ New-Item -ItemType Directory -Path $stateDir -Force | Out-Null }

  function To-PlainHashtable($obj){
    $h = @{}
    if($null -eq $obj){ return $h }
    if($obj -is [hashtable]){
      foreach($k in $obj.Keys){
        $v = $obj[$k]
        $h[[string]$k] = if($null -eq $v){ "" } else { [string]$v }
      }
      return $h
    }
    foreach($p in $obj.PSObject.Properties){
      $name = [string]$p.Name
      $val  = $p.Value
      $h[$name] = if($null -eq $val){ "" } else { [string]$val }
    }
    return $h
  }

  function Get-StableKey([string]$ev, $d){
    $ev2 = ([string]$ev).ToLowerInvariant()

    # Only rate-limit known noisy classes
    if($ev2 -notin @("tcp443_seen","lolbin_detected","dns_decision","doh_blocked","dns_blocked","dns_allowed","enforce_decision")){
      return $null
    }

    $h = To-PlainHashtable $d
    if($h.Count -eq 0){ return $null }

    # Event-specific minimal key (keeps suppression correct)
    $pairs = New-Object System.Collections.Generic.List[string]

    if($ev2 -eq "tcp443_seen"){
      # key on pid + remote + image (prevents log spam)
      $pid   = if($h.ContainsKey("pid")){ $h["pid"] } else { "" }
      $rem   = if($h.ContainsKey("remote")){ $h["remote"] } else { "" }
      $img   = if($h.ContainsKey("image")){ $h["image"] } else { "" }
      $pairs.Add("pid=$pid"); $pairs.Add("remote=$rem"); $pairs.Add("image=$img")
    }
    elseif($ev2 -eq "lolbin_detected"){
      # key on eventId + scriptblock id (best stability)
      $eid   = if($h.ContainsKey("eventId")){ $h["eventId"] } else { "" }
      $sbid  = ""
      if($h.ContainsKey("ScriptBlockId")){ $sbid = $h["ScriptBlockId"] }
      if([string]::IsNullOrWhiteSpace($sbid) -and $h.ContainsKey("scriptblockid")){ $sbid = $h["scriptblockid"] }
      $pairs.Add("eventid=$eid"); $pairs.Add("sbid=$sbid")
    }
    else {
      # default: sort keys for stable hashing
      foreach($k in ($h.Keys | Sort-Object)){
        $v = $h[$k]
        if($null -eq $v){ $v = "" }
        $pairs.Add(("{0}={1}" -f $k.ToLowerInvariant(), ($v.ToString().Trim())))
      }
    }

    $payload = $ev2 + "|" + ($pairs -join "|")

    $sha = [System.Security.Cryptography.SHA256]::Create()
    try{
      $bytes = [System.Text.Encoding]::UTF8.GetBytes($payload)
      $hash  = $sha.ComputeHash($bytes)
      return (-join ($hash | ForEach-Object { # --- Single-instance guard (mutex) ---
$mutexName = "Global\GuardianFW-ProcessDNS"
$mutex = New-Object System.Threading.Mutex($false, $mutexName)
$hasLock = $false
try {
  $hasLock = $mutex.WaitOne(0)
  if(-not $hasLock){ exit 0 }

Set-StrictMode -Version Latest
$ErrorActionPreference="Stop"

$Root="C:\ProgramData\GuardianFW"
$Policy=Join-Path $Root "policy\policy.json"
$DohIps=Join-Path $Root "policy\doh-ips.json"
$Audit=Join-Path $Root "logs\guardian-audit.jsonl"
$Fail =Join-Path $Root "sealed\FAIL_SECURE.flag"

function Write-Audit([string]$event,[hashtable]$data=@{}) {
  $dir = Split-Path $Audit
  if(!(Test-Path $dir)){ New-Item -ItemType Directory -Path $dir -Force | Out-Null }
    # ---- Compact huge events ----
  # ---- Drop noisy PowerShell ScriptBlock (4104) chunk spam mislabeled as lolbin ----
  # Enterprise-robust: the “Creating Scriptblock text …” spam may be in Message/message or elsewhere in $data.
  if($event -eq "lolbin_detected" -and $null -ne $data){
    $blob = ""
    try {
      # stringify entire data (handles hashtable, PSCustomObject, ordered dictionary, etc.)
      $blob = ($data | ConvertTo-Json -Compress -Depth 8)
    } catch {
      try { $blob = [string]$data } catch { $blob = "" }
    }

    if($blob -match '(?i)Creating\s+Scriptblock\s+text\s*\(' -or
       $blob -match '(?i)\beventId\s*=\s*4104\b' -or
       $blob -match '(?i)\bScriptBlock\s+ID\b' -or
       $blob -match '(?i)\bCmdletization\b'){
      return
    }
  }



  # ---- GuardianFW self-whitelist ----
  # If GuardianFW triggers ScriptBlock/PowerShell noise that gets labeled as lolbin_detected,
  # ignore it (prevents self-noise in enterprise telemetry).
  if($event -eq "lolbin_detected" -and $data -is [hashtable]){
    $msg = ""
    if($data.ContainsKey("message")){ $msg = [string]$data["message"] }

    $selfNeedles = @(
      "C:\ProgramData\GuardianFW\",
      "\ProgramData\GuardianFW\",
      "\GuardianFW\engine\",
      "process-dns-enforce.ps1",
      "GuardianFW-ProcessDNS",
      "GuardianControl",
      "GuardianAgent"
    )

    foreach($n in $selfNeedles){
      if($msg -like "*$n*"){ return }
    }

    # If later you add structured fields, honor them too
    if($data.ContainsKey("image") -and ([string]$data["image"] -like "*\GuardianFW\*")){ return }
  }
  # ---- Drop noisy PowerShell ScriptBlock (4104) chunk spam mislabeled as lolbin ----
  # Enterprise-robust: the “Creating Scriptblock text …” spam may be in Message/message or elsewhere in $data.
  if($event -eq "lolbin_detected" -and $null -ne $data){
    $blob = ""
    try {
      # stringify entire data (handles hashtable, PSCustomObject, ordered dictionary, etc.)
      $blob = ($data | ConvertTo-Json -Compress -Depth 8)
    } catch {
      try { $blob = [string]$data } catch { $blob = "" }
    }

    if($blob -match '(?i)Creating\s+Scriptblock\s+text\s*\(' -or
       $blob -match '(?i)\beventId\s*=\s*4104\b' -or
       $blob -match '(?i)\bScriptBlock\s+ID\b' -or
       $blob -match '(?i)\bCmdletization\b'){
      return
    }
  }


  # ---- Ignore GuardianFW self-activity ----
  if($event -eq "lolbin_detected" -and $data -is [hashtable]){
    $msg = ""
    if($data.ContainsKey("message")){ $msg = [string]$data["message"] }

    # Indicators that this is our own engine/services doing PowerShell work
    $selfHits = @(
      "C:\ProgramData\GuardianFW\",
      "\GuardianFW\",
      "GuardianFW-ProcessDNS",
      "process-dns-enforce.ps1",
      "GuardianAgent",
      "GuardianControl"
    )

    foreach($s in $selfHits){
      if($msg -like "*$s*"){ return }
    }

    # If in future you add structured fields, honor them too
    if($data.ContainsKey("image") -and ([string]$data["image"] -like "*GuardianFW*")){ return }
  }

  if($event -eq "lolbin_detected" -and $data -is [hashtable] -and $data.ContainsKey("message")){
    $msg = [string]$data["message"]
    # common 4104 chunk patterns
    if($msg -match '(?i)Creating Scriptblock text\s*\(' -or
       $msg -match '(?i)\beventId\s*=\s*4104\b' -or
       $msg -match '(?i)\bScriptBlock ID\b'){
      return
    }
  }

  if($event -eq "lolbin_detected" -and $data -is [hashtable] -and $data.ContainsKey("message")){
    $m = [string]$data["message"]
    if($m.Length -gt 600){ $data["message"] = $m.Substring(0,600) + "...(truncated)" }
  }
$rec=[pscustomobject]@{ tsUtc=(Get-Date).ToUniversalTime().ToString("o"); event=$event; data=$data }
  ($rec|ConvertTo-Json -Compress -Depth 12) | Add-Content -LiteralPath $Audit -Encoding UTF8
}

function HasProp($o,[string]$n){ return ($o -and $o.PSObject.Properties.Match($n).Count -gt 0) }

function Safe-LoadJson([string]$path){
  try { return (Get-Content -LiteralPath $path -Raw -Encoding UTF8 | ConvertFrom-Json) }
  catch { Write-Audit "json_load_failed" @{path=$path; error=$_.Exception.Message}; return $null }
}

# -------------------------
# Load policy
# -------------------------
$cfg = Safe-LoadJson $Policy
if($null -eq $cfg){ exit 0 }

if(-not (HasProp $cfg "process_dns_policy")){
  Write-Audit "process_dns_policy_missing" @{}
  exit 0
}

$pdp = $cfg.process_dns_policy
$mode="monitor"; $action="log"
if(HasProp $pdp "mode"){ $mode=[string]$pdp.mode }
if(HasProp $pdp "action"){ $action=[string]$pdp.action }

$rules=@()
if(HasProp $pdp "allow" -and $pdp.allow){ $rules=@($pdp.allow) }

function Is-AllowedImage([string]$img){
  foreach($r in $rules){
    if($r -and (HasProp $r "image") -and $r.image){
      if($img -ieq [string]$r.image){ return $true }
    }
  }
  return $false
}

# -------------------------
# Load DoH IP list (optional)
# -------------------------
$dohSet = @{}
$doh = Safe-LoadJson $DohIps
if($doh -and (HasProp $doh "providers") -and $doh.providers){
  foreach($prov in @($doh.providers)){
    if($prov -and (HasProp $prov "ips") -and $prov.ips){
      $pname = $null
      if(HasProp $prov "name"){ $pname = [string]$prov.name }
      foreach($ip in @($prov.ips)){
        if($ip){ $dohSet[[string]$ip] = $pname }
      }
    }
  }
}

# -------------------------
# DNS53 detection:
# - UDP: LocalPort == 53
# - TCP: RemotePort == 53
# -------------------------
$udp = Get-NetUDPEndpoint -ErrorAction SilentlyContinue | Where-Object { $_.LocalPort -eq 53 }
foreach($u in $udp){
  $ProcId=[int]$u.OwningProcess
  if($ProcId -le 4){ continue }

  $p = Get-Process -Id $ProcId -ErrorAction SilentlyContinue
  if(!$p -or -not $p.Path){ continue }
  $img=[string]$p.Path

  if(-not (Is-AllowedImage $img)){
    Write-Audit "process_dns_violation" @{
      kind="dns53_udp"; pid=$ProcId; image=$img;
      local=$u.LocalAddress; lport=$u.LocalPort;
      mode=$mode; action=$action
    }

    if($mode -ieq "enforce" -and $action -ieq "kill"){
      try { Stop-Process -Id $ProcId -Force; Write-Audit "process_dns_killed" @{kind="dns53_udp"; pid=$ProcId; image=$img} }
      catch { Write-Audit "process_dns_kill_failed" @{kind="dns53_udp"; pid=$ProcId; image=$img; error=$_.Exception.Message}; New-Item -ItemType File -Path $Fail -Force | Out-Null }
    }
  }
}

$tcp53 = Get-NetTCPConnection -State Established -ErrorAction SilentlyContinue | Where-Object { $_.RemotePort -eq 53 }
foreach($c in $tcp53){
  $ProcId=[int]$c.OwningProcess
  if($ProcId -le 4){ continue }

  $p = Get-Process -Id $ProcId -ErrorAction SilentlyContinue
  if(!$p -or -not $p.Path){ continue }
  $img=[string]$p.Path

  if(-not (Is-AllowedImage $img)){
    Write-Audit "process_dns_violation" @{
      kind="dns53_tcp"; pid=$ProcId; image=$img; remote=$c.RemoteAddress; port=$c.RemotePort;
      mode=$mode; action=$action
    }

    if($mode -ieq "enforce" -and $action -ieq "kill"){
      try { Stop-Process -Id $ProcId -Force; Write-Audit "process_dns_killed" @{kind="dns53_tcp"; pid=$ProcId; image=$img} }
      catch { Write-Audit "process_dns_kill_failed" @{kind="dns53_tcp"; pid=$ProcId; image=$img; error=$_.Exception.Message}; New-Item -ItemType File -Path $Fail -Force | Out-Null }
    }
  }
}

# -------------------------
# DoH IP correlation (SAFE):
# - TCP 443 only if RemoteAddress is in doh-ips.json
# - Include short-lived states to increase capture chance
# -------------------------
if($dohSet.Count -gt 0){
  $tcp443 = Get-NetTCPConnection -ErrorAction SilentlyContinue |
            Where-Object { $_.RemotePort -eq 443 -and $_.State -in @("Established","SynSent","TimeWait") }

  foreach($c in $tcp443){
    $rip = [string]$c.RemoteAddress
    if(-not $rip){ continue }
    if(-not $dohSet.ContainsKey($rip)){ continue }

    $ProcId=[int]$c.OwningProcess
    if($ProcId -le 4){ continue }

    $p = Get-Process -Id $ProcId -ErrorAction SilentlyContinue
    $img = $null
    if($p -and $p.Path){ $img = [string]$p.Path }

    $provider = $dohSet[$rip]

    Write-Audit "process_dns_violation" @{
      kind="doh_ip_hit"; pid=$ProcId; image=$img; remote=$rip; port=443; provider=$provider;
      mode=$mode; action=$action
    }

    if($Host.Name -match "ConsoleHost"){
      Write-Host ("DoH hit: {0} {1} {2}" -f $provider, $rip, $img)
    }

    if($mode -ieq "enforce" -and $action -ieq "kill"){
      try { Stop-Process -Id $ProcId -Force; Write-Audit "process_dns_killed" @{kind="doh_ip_hit"; pid=$ProcId; image=$img; remote=$rip; provider=$provider} }
      catch { Write-Audit "process_dns_kill_failed" @{kind="doh_ip_hit"; pid=$ProcId; image=$img; remote=$rip; provider=$provider; error=$_.Exception.Message}; New-Item -ItemType File -Path $Fail -Force | Out-Null }
    }
  }
}

# -------------------------
# DEBUG: observe 443 remotes (always)
# -------------------------
try {
  $tcp443all = Get-NetTCPConnection -State Established -ErrorAction SilentlyContinue | Where-Object { $_.RemotePort -eq 443 }
  foreach($c in $tcp443all){
    $ProcId=[int]$c.OwningProcess
    if($ProcId -le 4){ continue }

    $p = Get-Process -Id $ProcId -ErrorAction SilentlyContinue
    $img=$null
    if($p -and $p.Path){ $img=[string]$p.Path }

    $rip=[string]$c.RemoteAddress
    if(-not $rip){ continue }

    $prov=$null
    if($dohSet.Count -gt 0 -and $dohSet.ContainsKey($rip)){ $prov=$dohSet[$rip] }

    Write-Audit "tcp443_seen" @{ pid=$ProcId; image=$img; remote=$rip; provider=$prov }
  }
} catch {
  Write-Audit "tcp443_seen_failed" @{ error=$_.Exception.Message }
}

# Optional pause when manual:
#   setx GUARDIANFW_PAUSE 1
if($Host.Name -match "ConsoleHost" -and $env:GUARDIANFW_PAUSE -eq "1"){
  Read-Host "Press Enter" | Out-Null
}

exit 0

} finally {
  if($hasLock){ $mutex.ReleaseMutex() | Out-Null }
  $mutex.Dispose()
}


.ToString("x2") }))
    } finally { $sha.Dispose() }
  }

  # event-specific min gaps
  $minGapSec = switch -Regex ($event) {
    '^tcp443_seen

function HasProp($o,[string]$n){ return ($o -and $o.PSObject.Properties.Match($n).Count -gt 0) }

function Safe-LoadJson([string]$path){
  try { return (Get-Content -LiteralPath $path -Raw -Encoding UTF8 | ConvertFrom-Json) }
  catch { Write-Audit "json_load_failed" @{path=$path; error=$_.Exception.Message}; return $null }
}

# -------------------------
# Load policy
# -------------------------
$cfg = Safe-LoadJson $Policy
if($null -eq $cfg){ exit 0 }

if(-not (HasProp $cfg "process_dns_policy")){
  Write-Audit "process_dns_policy_missing" @{}
  exit 0
}

$pdp = $cfg.process_dns_policy
$mode="monitor"; $action="log"
if(HasProp $pdp "mode"){ $mode=[string]$pdp.mode }
if(HasProp $pdp "action"){ $action=[string]$pdp.action }

$rules=@()
if(HasProp $pdp "allow" -and $pdp.allow){ $rules=@($pdp.allow) }

function Is-AllowedImage([string]$img){
  foreach($r in $rules){
    if($r -and (HasProp $r "image") -and $r.image){
      if($img -ieq [string]$r.image){ return $true }
    }
  }
  return $false
}

# -------------------------
# Load DoH IP list (optional)
# -------------------------
$dohSet = @{}
$doh = Safe-LoadJson $DohIps
if($doh -and (HasProp $doh "providers") -and $doh.providers){
  foreach($prov in @($doh.providers)){
    if($prov -and (HasProp $prov "ips") -and $prov.ips){
      $pname = $null
      if(HasProp $prov "name"){ $pname = [string]$prov.name }
      foreach($ip in @($prov.ips)){
        if($ip){ $dohSet[[string]$ip] = $pname }
      }
    }
  }
}

# -------------------------
# DNS53 detection:
# - UDP: LocalPort == 53
# - TCP: RemotePort == 53
# -------------------------
$udp = Get-NetUDPEndpoint -ErrorAction SilentlyContinue | Where-Object { $_.LocalPort -eq 53 }
foreach($u in $udp){
  $ProcId=[int]$u.OwningProcess
  if($ProcId -le 4){ continue }

  $p = Get-Process -Id $ProcId -ErrorAction SilentlyContinue
  if(!$p -or -not $p.Path){ continue }
  $img=[string]$p.Path

  if(-not (Is-AllowedImage $img)){
    Write-Audit "process_dns_violation" @{
      kind="dns53_udp"; pid=$ProcId; image=$img;
      local=$u.LocalAddress; lport=$u.LocalPort;
      mode=$mode; action=$action
    }

    if($mode -ieq "enforce" -and $action -ieq "kill"){
      try { Stop-Process -Id $ProcId -Force; Write-Audit "process_dns_killed" @{kind="dns53_udp"; pid=$ProcId; image=$img} }
      catch { Write-Audit "process_dns_kill_failed" @{kind="dns53_udp"; pid=$ProcId; image=$img; error=$_.Exception.Message}; New-Item -ItemType File -Path $Fail -Force | Out-Null }
    }
  }
}

$tcp53 = Get-NetTCPConnection -State Established -ErrorAction SilentlyContinue | Where-Object { $_.RemotePort -eq 53 }
foreach($c in $tcp53){
  $ProcId=[int]$c.OwningProcess
  if($ProcId -le 4){ continue }

  $p = Get-Process -Id $ProcId -ErrorAction SilentlyContinue
  if(!$p -or -not $p.Path){ continue }
  $img=[string]$p.Path

  if(-not (Is-AllowedImage $img)){
    Write-Audit "process_dns_violation" @{
      kind="dns53_tcp"; pid=$ProcId; image=$img; remote=$c.RemoteAddress; port=$c.RemotePort;
      mode=$mode; action=$action
    }

    if($mode -ieq "enforce" -and $action -ieq "kill"){
      try { Stop-Process -Id $ProcId -Force; Write-Audit "process_dns_killed" @{kind="dns53_tcp"; pid=$ProcId; image=$img} }
      catch { Write-Audit "process_dns_kill_failed" @{kind="dns53_tcp"; pid=$ProcId; image=$img; error=$_.Exception.Message}; New-Item -ItemType File -Path $Fail -Force | Out-Null }
    }
  }
}

# -------------------------
# DoH IP correlation (SAFE):
# - TCP 443 only if RemoteAddress is in doh-ips.json
# - Include short-lived states to increase capture chance
# -------------------------
if($dohSet.Count -gt 0){
  $tcp443 = Get-NetTCPConnection -ErrorAction SilentlyContinue |
            Where-Object { $_.RemotePort -eq 443 -and $_.State -in @("Established","SynSent","TimeWait") }

  foreach($c in $tcp443){
    $rip = [string]$c.RemoteAddress
    if(-not $rip){ continue }
    if(-not $dohSet.ContainsKey($rip)){ continue }

    $ProcId=[int]$c.OwningProcess
    if($ProcId -le 4){ continue }

    $p = Get-Process -Id $ProcId -ErrorAction SilentlyContinue
    $img = $null
    if($p -and $p.Path){ $img = [string]$p.Path }

    $provider = $dohSet[$rip]

    Write-Audit "process_dns_violation" @{
      kind="doh_ip_hit"; pid=$ProcId; image=$img; remote=$rip; port=443; provider=$provider;
      mode=$mode; action=$action
    }

    if($Host.Name -match "ConsoleHost"){
      Write-Host ("DoH hit: {0} {1} {2}" -f $provider, $rip, $img)
    }

    if($mode -ieq "enforce" -and $action -ieq "kill"){
      try { Stop-Process -Id $ProcId -Force; Write-Audit "process_dns_killed" @{kind="doh_ip_hit"; pid=$ProcId; image=$img; remote=$rip; provider=$provider} }
      catch { Write-Audit "process_dns_kill_failed" @{kind="doh_ip_hit"; pid=$ProcId; image=$img; remote=$rip; provider=$provider; error=$_.Exception.Message}; New-Item -ItemType File -Path $Fail -Force | Out-Null }
    }
  }
}

# -------------------------
# DEBUG: observe 443 remotes (always)
# -------------------------
try {
  $tcp443all = Get-NetTCPConnection -State Established -ErrorAction SilentlyContinue | Where-Object { $_.RemotePort -eq 443 }
  foreach($c in $tcp443all){
    $ProcId=[int]$c.OwningProcess
    if($ProcId -le 4){ continue }

    $p = Get-Process -Id $ProcId -ErrorAction SilentlyContinue
    $img=$null
    if($p -and $p.Path){ $img=[string]$p.Path }

    $rip=[string]$c.RemoteAddress
    if(-not $rip){ continue }

    $prov=$null
    if($dohSet.Count -gt 0 -and $dohSet.ContainsKey($rip)){ $prov=$dohSet[$rip] }

    Write-Audit "tcp443_seen" @{ pid=$ProcId; image=$img; remote=$rip; provider=$prov }
  }
} catch {
  Write-Audit "tcp443_seen_failed" @{ error=$_.Exception.Message }
}

# Optional pause when manual:
#   setx GUARDIANFW_PAUSE 1
if($Host.Name -match "ConsoleHost" -and $env:GUARDIANFW_PAUSE -eq "1"){
  Read-Host "Press Enter" | Out-Null
}

exit 0

} finally {
  if($hasLock){ $mutex.ReleaseMutex() | Out-Null }
  $mutex.Dispose()
}


      { 300 }   # 5 min per (pid+remote+image)
    '^lolbin_detected

function HasProp($o,[string]$n){ return ($o -and $o.PSObject.Properties.Match($n).Count -gt 0) }

function Safe-LoadJson([string]$path){
  try { return (Get-Content -LiteralPath $path -Raw -Encoding UTF8 | ConvertFrom-Json) }
  catch { Write-Audit "json_load_failed" @{path=$path; error=$_.Exception.Message}; return $null }
}

# -------------------------
# Load policy
# -------------------------
$cfg = Safe-LoadJson $Policy
if($null -eq $cfg){ exit 0 }

if(-not (HasProp $cfg "process_dns_policy")){
  Write-Audit "process_dns_policy_missing" @{}
  exit 0
}

$pdp = $cfg.process_dns_policy
$mode="monitor"; $action="log"
if(HasProp $pdp "mode"){ $mode=[string]$pdp.mode }
if(HasProp $pdp "action"){ $action=[string]$pdp.action }

$rules=@()
if(HasProp $pdp "allow" -and $pdp.allow){ $rules=@($pdp.allow) }

function Is-AllowedImage([string]$img){
  foreach($r in $rules){
    if($r -and (HasProp $r "image") -and $r.image){
      if($img -ieq [string]$r.image){ return $true }
    }
  }
  return $false
}

# -------------------------
# Load DoH IP list (optional)
# -------------------------
$dohSet = @{}
$doh = Safe-LoadJson $DohIps
if($doh -and (HasProp $doh "providers") -and $doh.providers){
  foreach($prov in @($doh.providers)){
    if($prov -and (HasProp $prov "ips") -and $prov.ips){
      $pname = $null
      if(HasProp $prov "name"){ $pname = [string]$prov.name }
      foreach($ip in @($prov.ips)){
        if($ip){ $dohSet[[string]$ip] = $pname }
      }
    }
  }
}

# -------------------------
# DNS53 detection:
# - UDP: LocalPort == 53
# - TCP: RemotePort == 53
# -------------------------
$udp = Get-NetUDPEndpoint -ErrorAction SilentlyContinue | Where-Object { $_.LocalPort -eq 53 }
foreach($u in $udp){
  $ProcId=[int]$u.OwningProcess
  if($ProcId -le 4){ continue }

  $p = Get-Process -Id $ProcId -ErrorAction SilentlyContinue
  if(!$p -or -not $p.Path){ continue }
  $img=[string]$p.Path

  if(-not (Is-AllowedImage $img)){
    Write-Audit "process_dns_violation" @{
      kind="dns53_udp"; pid=$ProcId; image=$img;
      local=$u.LocalAddress; lport=$u.LocalPort;
      mode=$mode; action=$action
    }

    if($mode -ieq "enforce" -and $action -ieq "kill"){
      try { Stop-Process -Id $ProcId -Force; Write-Audit "process_dns_killed" @{kind="dns53_udp"; pid=$ProcId; image=$img} }
      catch { Write-Audit "process_dns_kill_failed" @{kind="dns53_udp"; pid=$ProcId; image=$img; error=$_.Exception.Message}; New-Item -ItemType File -Path $Fail -Force | Out-Null }
    }
  }
}

$tcp53 = Get-NetTCPConnection -State Established -ErrorAction SilentlyContinue | Where-Object { $_.RemotePort -eq 53 }
foreach($c in $tcp53){
  $ProcId=[int]$c.OwningProcess
  if($ProcId -le 4){ continue }

  $p = Get-Process -Id $ProcId -ErrorAction SilentlyContinue
  if(!$p -or -not $p.Path){ continue }
  $img=[string]$p.Path

  if(-not (Is-AllowedImage $img)){
    Write-Audit "process_dns_violation" @{
      kind="dns53_tcp"; pid=$ProcId; image=$img; remote=$c.RemoteAddress; port=$c.RemotePort;
      mode=$mode; action=$action
    }

    if($mode -ieq "enforce" -and $action -ieq "kill"){
      try { Stop-Process -Id $ProcId -Force; Write-Audit "process_dns_killed" @{kind="dns53_tcp"; pid=$ProcId; image=$img} }
      catch { Write-Audit "process_dns_kill_failed" @{kind="dns53_tcp"; pid=$ProcId; image=$img; error=$_.Exception.Message}; New-Item -ItemType File -Path $Fail -Force | Out-Null }
    }
  }
}

# -------------------------
# DoH IP correlation (SAFE):
# - TCP 443 only if RemoteAddress is in doh-ips.json
# - Include short-lived states to increase capture chance
# -------------------------
if($dohSet.Count -gt 0){
  $tcp443 = Get-NetTCPConnection -ErrorAction SilentlyContinue |
            Where-Object { $_.RemotePort -eq 443 -and $_.State -in @("Established","SynSent","TimeWait") }

  foreach($c in $tcp443){
    $rip = [string]$c.RemoteAddress
    if(-not $rip){ continue }
    if(-not $dohSet.ContainsKey($rip)){ continue }

    $ProcId=[int]$c.OwningProcess
    if($ProcId -le 4){ continue }

    $p = Get-Process -Id $ProcId -ErrorAction SilentlyContinue
    $img = $null
    if($p -and $p.Path){ $img = [string]$p.Path }

    $provider = $dohSet[$rip]

    Write-Audit "process_dns_violation" @{
      kind="doh_ip_hit"; pid=$ProcId; image=$img; remote=$rip; port=443; provider=$provider;
      mode=$mode; action=$action
    }

    if($Host.Name -match "ConsoleHost"){
      Write-Host ("DoH hit: {0} {1} {2}" -f $provider, $rip, $img)
    }

    if($mode -ieq "enforce" -and $action -ieq "kill"){
      try { Stop-Process -Id $ProcId -Force; Write-Audit "process_dns_killed" @{kind="doh_ip_hit"; pid=$ProcId; image=$img; remote=$rip; provider=$provider} }
      catch { Write-Audit "process_dns_kill_failed" @{kind="doh_ip_hit"; pid=$ProcId; image=$img; remote=$rip; provider=$provider; error=$_.Exception.Message}; New-Item -ItemType File -Path $Fail -Force | Out-Null }
    }
  }
}

# -------------------------
# DEBUG: observe 443 remotes (always)
# -------------------------
try {
  $tcp443all = Get-NetTCPConnection -State Established -ErrorAction SilentlyContinue | Where-Object { $_.RemotePort -eq 443 }
  foreach($c in $tcp443all){
    $ProcId=[int]$c.OwningProcess
    if($ProcId -le 4){ continue }

    $p = Get-Process -Id $ProcId -ErrorAction SilentlyContinue
    $img=$null
    if($p -and $p.Path){ $img=[string]$p.Path }

    $rip=[string]$c.RemoteAddress
    if(-not $rip){ continue }

    $prov=$null
    if($dohSet.Count -gt 0 -and $dohSet.ContainsKey($rip)){ $prov=$dohSet[$rip] }

    Write-Audit "tcp443_seen" @{ pid=$ProcId; image=$img; remote=$rip; provider=$prov }
  }
} catch {
  Write-Audit "tcp443_seen_failed" @{ error=$_.Exception.Message }
}

# Optional pause when manual:
#   setx GUARDIANFW_PAUSE 1
if($Host.Name -match "ConsoleHost" -and $env:GUARDIANFW_PAUSE -eq "1"){
  Read-Host "Press Enter" | Out-Null
}

exit 0

} finally {
  if($hasLock){ $mutex.ReleaseMutex() | Out-Null }
  $mutex.Dispose()
}


  { 3600 }  # 60 min per (eventId+ScriptBlockId)
    default              { 300 }   # 5 min for other noisy classes
  }

  $key = Get-StableKey $event $data
  $now = [DateTime]::UtcNow

  # load state (json -> hashtable)
  $state = @{}
  if(Test-Path $stateFile){
    try{
      $obj = Get-Content $stateFile -Raw -Encoding UTF8 | ConvertFrom-Json
      if($obj){
        foreach($prop in $obj.PSObject.Properties){
          $state[$prop.Name] = [string]$prop.Value
        }
      }
    } catch { $state = @{} }
  }

  # prune old keys (>2 days)
  foreach($k in @($state.Keys)){
    try{
      $t = [DateTime]::Parse($state[$k]).ToUniversalTime()
      if(($now - $t).TotalDays -gt 2){ $state.Remove($k) }
    } catch { $state.Remove($k) }
  }

  # suppress duplicates
  if($null -ne $key -and $state.ContainsKey($key)){
    $last = $null
    try { $last = [DateTime]::Parse($state[$key]).ToUniversalTime() } catch { $last = $null }
    if($null -ne $last -and ($now - $last).TotalSeconds -lt $minGapSec){
      return
    }
  }

  # write audit record
  $rec=[pscustomobject]@{
    tsUtc = (Get-Date).ToUniversalTime().ToString("o")
    event = $event
    data  = $data
  }
  ($rec|ConvertTo-Json -Compress -Depth 12) | Add-Content -LiteralPath $Audit -Encoding UTF8

  # update state
  if($null -ne $key){
    $state[$key] = $now.ToString("o")
    try { ($state | ConvertTo-Json -Depth 6) | Set-Content -LiteralPath $stateFile -Encoding UTF8 } catch { }
  }
}

function HasProp($o,[string]$n){ return ($o -and $o.PSObject.Properties.Match($n).Count -gt 0) }

function Safe-LoadJson([string]$path){
  try { return (Get-Content -LiteralPath $path -Raw -Encoding UTF8 | ConvertFrom-Json) }
  catch { Write-Audit "json_load_failed" @{path=$path; error=$_.Exception.Message}; return $null }
}

# -------------------------
# Load policy
# -------------------------
$cfg = Safe-LoadJson $Policy
if($null -eq $cfg){ exit 0 }

if(-not (HasProp $cfg "process_dns_policy")){
  Write-Audit "process_dns_policy_missing" @{}
  exit 0
}

$pdp = $cfg.process_dns_policy
$mode="monitor"; $action="log"
if(HasProp $pdp "mode"){ $mode=[string]$pdp.mode }
if(HasProp $pdp "action"){ $action=[string]$pdp.action }

$rules=@()
if(HasProp $pdp "allow" -and $pdp.allow){ $rules=@($pdp.allow) }

function Is-AllowedImage([string]$img){
  foreach($r in $rules){
    if($r -and (HasProp $r "image") -and $r.image){
      if($img -ieq [string]$r.image){ return $true }
    }
  }
  return $false
}

# -------------------------
# Load DoH IP list (optional)
# -------------------------
$dohSet = @{}
$doh = Safe-LoadJson $DohIps
if($doh -and (HasProp $doh "providers") -and $doh.providers){
  foreach($prov in @($doh.providers)){
    if($prov -and (HasProp $prov "ips") -and $prov.ips){
      $pname = $null
      if(HasProp $prov "name"){ $pname = [string]$prov.name }
      foreach($ip in @($prov.ips)){
        if($ip){ $dohSet[[string]$ip] = $pname }
      }
    }
  }
}

# -------------------------
# DNS53 detection:
# - UDP: LocalPort == 53
# - TCP: RemotePort == 53
# -------------------------
$udp = Get-NetUDPEndpoint -ErrorAction SilentlyContinue | Where-Object { $_.LocalPort -eq 53 }
foreach($u in $udp){
  $ProcId=[int]$u.OwningProcess
  if($ProcId -le 4){ continue }

  $p = Get-Process -Id $ProcId -ErrorAction SilentlyContinue
  if(!$p -or -not $p.Path){ continue }
  $img=[string]$p.Path

  if(-not (Is-AllowedImage $img)){
    Write-Audit "process_dns_violation" @{
      kind="dns53_udp"; pid=$ProcId; image=$img;
      local=$u.LocalAddress; lport=$u.LocalPort;
      mode=$mode; action=$action
    }

    if($mode -ieq "enforce" -and $action -ieq "kill"){
      try { Stop-Process -Id $ProcId -Force; Write-Audit "process_dns_killed" @{kind="dns53_udp"; pid=$ProcId; image=$img} }
      catch { Write-Audit "process_dns_kill_failed" @{kind="dns53_udp"; pid=$ProcId; image=$img; error=$_.Exception.Message}; New-Item -ItemType File -Path $Fail -Force | Out-Null }
    }
  }
}

$tcp53 = Get-NetTCPConnection -State Established -ErrorAction SilentlyContinue | Where-Object { $_.RemotePort -eq 53 }
foreach($c in $tcp53){
  $ProcId=[int]$c.OwningProcess
  if($ProcId -le 4){ continue }

  $p = Get-Process -Id $ProcId -ErrorAction SilentlyContinue
  if(!$p -or -not $p.Path){ continue }
  $img=[string]$p.Path

  if(-not (Is-AllowedImage $img)){
    Write-Audit "process_dns_violation" @{
      kind="dns53_tcp"; pid=$ProcId; image=$img; remote=$c.RemoteAddress; port=$c.RemotePort;
      mode=$mode; action=$action
    }

    if($mode -ieq "enforce" -and $action -ieq "kill"){
      try { Stop-Process -Id $ProcId -Force; Write-Audit "process_dns_killed" @{kind="dns53_tcp"; pid=$ProcId; image=$img} }
      catch { Write-Audit "process_dns_kill_failed" @{kind="dns53_tcp"; pid=$ProcId; image=$img; error=$_.Exception.Message}; New-Item -ItemType File -Path $Fail -Force | Out-Null }
    }
  }
}

# -------------------------
# DoH IP correlation (SAFE):
# - TCP 443 only if RemoteAddress is in doh-ips.json
# - Include short-lived states to increase capture chance
# -------------------------
if($dohSet.Count -gt 0){
  $tcp443 = Get-NetTCPConnection -ErrorAction SilentlyContinue |
            Where-Object { $_.RemotePort -eq 443 -and $_.State -in @("Established","SynSent","TimeWait") }

  foreach($c in $tcp443){
    $rip = [string]$c.RemoteAddress
    if(-not $rip){ continue }
    if(-not $dohSet.ContainsKey($rip)){ continue }

    $ProcId=[int]$c.OwningProcess
    if($ProcId -le 4){ continue }

    $p = Get-Process -Id $ProcId -ErrorAction SilentlyContinue
    $img = $null
    if($p -and $p.Path){ $img = [string]$p.Path }

    $provider = $dohSet[$rip]

    Write-Audit "process_dns_violation" @{
      kind="doh_ip_hit"; pid=$ProcId; image=$img; remote=$rip; port=443; provider=$provider;
      mode=$mode; action=$action
    }

    if($Host.Name -match "ConsoleHost"){
      Write-Host ("DoH hit: {0} {1} {2}" -f $provider, $rip, $img)
    }

    if($mode -ieq "enforce" -and $action -ieq "kill"){
      try { Stop-Process -Id $ProcId -Force; Write-Audit "process_dns_killed" @{kind="doh_ip_hit"; pid=$ProcId; image=$img; remote=$rip; provider=$provider} }
      catch { Write-Audit "process_dns_kill_failed" @{kind="doh_ip_hit"; pid=$ProcId; image=$img; remote=$rip; provider=$provider; error=$_.Exception.Message}; New-Item -ItemType File -Path $Fail -Force | Out-Null }
    }
  }
}

# -------------------------
# DEBUG: observe 443 remotes (always)
# -------------------------
try {
  $tcp443all = Get-NetTCPConnection -State Established -ErrorAction SilentlyContinue | Where-Object { $_.RemotePort -eq 443 }
  foreach($c in $tcp443all){
    $ProcId=[int]$c.OwningProcess
    if($ProcId -le 4){ continue }

    $p = Get-Process -Id $ProcId -ErrorAction SilentlyContinue
    $img=$null
    if($p -and $p.Path){ $img=[string]$p.Path }

    $rip=[string]$c.RemoteAddress
    if(-not $rip){ continue }

    $prov=$null
    if($dohSet.Count -gt 0 -and $dohSet.ContainsKey($rip)){ $prov=$dohSet[$rip] }

    Write-Audit "tcp443_seen" @{ pid=$ProcId; image=$img; remote=$rip; provider=$prov }
  }
} catch {
  Write-Audit "tcp443_seen_failed" @{ error=$_.Exception.Message }
}

# Optional pause when manual:
#   setx GUARDIANFW_PAUSE 1
if($Host.Name -match "ConsoleHost" -and $env:GUARDIANFW_PAUSE -eq "1"){
  Read-Host "Press Enter" | Out-Null
}

exit 0

} finally {
  if($hasLock){ $mutex.ReleaseMutex() | Out-Null }
  $mutex.Dispose()
}








.ToString("x2") }))
    } finally { $sha.Dispose() }
  }

  $minGapSec = switch ($ev) {
    "tcp443_seen"     { 300 }
    "lolbin_detected" { 3600 }
    default           { 300 }
  }

  $key = Get-StableKey $ev $data
  $now = [DateTime]::UtcNow

  $state = @{}
  if(Test-Path $stateFile){
    try{
      $obj = Get-Content $stateFile -Raw -Encoding UTF8 | ConvertFrom-Json
      if($obj){
        foreach($prop in $obj.PSObject.Properties){
          $state[$prop.Name] = [string]$prop.Value
        }
      }
    } catch { $state = @{} }
  }

  foreach($k in @($state.Keys)){
    try{
      $t = [DateTime]::Parse($state[$k]).ToUniversalTime()
      if(($now - $t).TotalDays -gt 2){ $state.Remove($k) }
    } catch { $state.Remove($k) }
  }

  if($null -ne $key -and $state.ContainsKey($key)){
    $last = $null
    try { $last = [DateTime]::Parse($state[$key]).ToUniversalTime() } catch { $last = $null }
    if($null -ne $last -and ($now - $last).TotalSeconds -lt $minGapSec){
      return
    }
  }

  # write
  $rec=[pscustomobject]@{
    tsUtc = (Get-Date).ToUniversalTime().ToString("o")
    event = $ev
    data  = $data
  }
  ($rec|ConvertTo-Json -Compress -Depth 12) | Add-Content -LiteralPath $Audit -Encoding UTF8

  if($null -ne $key){
    $state[$key] = $now.ToString("o")
    try { ($state | ConvertTo-Json -Depth 6) | Set-Content -LiteralPath $stateFile -Encoding UTF8 } catch { }
  }
}

function HasProp($o,[string]$n){ return ($o -and $o.PSObject.Properties.Match($n).Count -gt 0) }

function Safe-LoadJson([string]$path){
  try { return (Get-Content -LiteralPath $path -Raw -Encoding UTF8 | ConvertFrom-Json) }
  catch { Write-Audit "json_load_failed" @{path=$path; error=$_.Exception.Message}; return $null }
}

# -------------------------
# Load policy
# -------------------------
$cfg = Safe-LoadJson $Policy
if($null -eq $cfg){ exit 0 }

if(-not (HasProp $cfg "process_dns_policy")){
  Write-Audit "process_dns_policy_missing" @{}
  exit 0
}

$pdp = $cfg.process_dns_policy
$mode="monitor"; $action="log"
if(HasProp $pdp "mode"){ $mode=[string]$pdp.mode }
if(HasProp $pdp "action"){ $action=[string]$pdp.action }

$rules=@()
if(HasProp $pdp "allow" -and $pdp.allow){ $rules=@($pdp.allow) }

function Is-AllowedImage([string]$img){
  foreach($r in $rules){
    if($r -and (HasProp $r "image") -and $r.image){
      if($img -ieq [string]$r.image){ return $true }
    }
  }
  return $false
}

# -------------------------
# Load DoH IP list (optional)
# -------------------------
$dohSet = @{}
$doh = Safe-LoadJson $DohIps
if($doh -and (HasProp $doh "providers") -and $doh.providers){
  foreach($prov in @($doh.providers)){
    if($prov -and (HasProp $prov "ips") -and $prov.ips){
      $pname = $null
      if(HasProp $prov "name"){ $pname = [string]$prov.name }
      foreach($ip in @($prov.ips)){
        if($ip){ $dohSet[[string]$ip] = $pname }
      }
    }
  }
}

# -------------------------
# DNS53 detection:
# - UDP: LocalPort == 53
# - TCP: RemotePort == 53
# -------------------------
$udp = Get-NetUDPEndpoint -ErrorAction SilentlyContinue | Where-Object { $_.LocalPort -eq 53 }
foreach($u in $udp){
  $ProcId=[int]$u.OwningProcess
  if($ProcId -le 4){ continue }

  $p = Get-Process -Id $ProcId -ErrorAction SilentlyContinue
  if(!$p -or -not $p.Path){ continue }
  $img=[string]$p.Path

  if(-not (Is-AllowedImage $img)){
    Write-Audit "process_dns_violation" @{
      kind="dns53_udp"; pid=$ProcId; image=$img;
      local=$u.LocalAddress; lport=$u.LocalPort;
      mode=$mode; action=$action
    }

    if($mode -ieq "enforce" -and $action -ieq "kill"){
      try { Stop-Process -Id $ProcId -Force; Write-Audit "process_dns_killed" @{kind="dns53_udp"; pid=$ProcId; image=$img} }
      catch { Write-Audit "process_dns_kill_failed" @{kind="dns53_udp"; pid=$ProcId; image=$img; error=$_.Exception.Message}; New-Item -ItemType File -Path $Fail -Force | Out-Null }
    }
  }
}

$tcp53 = Get-NetTCPConnection -State Established -ErrorAction SilentlyContinue | Where-Object { $_.RemotePort -eq 53 }
foreach($c in $tcp53){
  $ProcId=[int]$c.OwningProcess
  if($ProcId -le 4){ continue }

  $p = Get-Process -Id $ProcId -ErrorAction SilentlyContinue
  if(!$p -or -not $p.Path){ continue }
  $img=[string]$p.Path

  if(-not (Is-AllowedImage $img)){
    Write-Audit "process_dns_violation" @{
      kind="dns53_tcp"; pid=$ProcId; image=$img; remote=$c.RemoteAddress; port=$c.RemotePort;
      mode=$mode; action=$action
    }

    if($mode -ieq "enforce" -and $action -ieq "kill"){
      try { Stop-Process -Id $ProcId -Force; Write-Audit "process_dns_killed" @{kind="dns53_tcp"; pid=$ProcId; image=$img} }
      catch { Write-Audit "process_dns_kill_failed" @{kind="dns53_tcp"; pid=$ProcId; image=$img; error=$_.Exception.Message}; New-Item -ItemType File -Path $Fail -Force | Out-Null }
    }
  }
}

# -------------------------
# DoH IP correlation (SAFE):
# - TCP 443 only if RemoteAddress is in doh-ips.json
# - Include short-lived states to increase capture chance
# -------------------------
if($dohSet.Count -gt 0){
  $tcp443 = Get-NetTCPConnection -ErrorAction SilentlyContinue |
            Where-Object { $_.RemotePort -eq 443 -and $_.State -in @("Established","SynSent","TimeWait") }

  foreach($c in $tcp443){
    $rip = [string]$c.RemoteAddress
    if(-not $rip){ continue }
    if(-not $dohSet.ContainsKey($rip)){ continue }

    $ProcId=[int]$c.OwningProcess
    if($ProcId -le 4){ continue }

    $p = Get-Process -Id $ProcId -ErrorAction SilentlyContinue
    $img = $null
    if($p -and $p.Path){ $img = [string]$p.Path }

    $provider = $dohSet[$rip]

    Write-Audit "process_dns_violation" @{
      kind="doh_ip_hit"; pid=$ProcId; image=$img; remote=$rip; port=443; provider=$provider;
      mode=$mode; action=$action
    }

    if($Host.Name -match "ConsoleHost"){
      Write-Host ("DoH hit: {0} {1} {2}" -f $provider, $rip, $img)
    }

    if($mode -ieq "enforce" -and $action -ieq "kill"){
      try { Stop-Process -Id $ProcId -Force; Write-Audit "process_dns_killed" @{kind="doh_ip_hit"; pid=$ProcId; image=$img; remote=$rip; provider=$provider} }
      catch { Write-Audit "process_dns_kill_failed" @{kind="doh_ip_hit"; pid=$ProcId; image=$img; remote=$rip; provider=$provider; error=$_.Exception.Message}; New-Item -ItemType File -Path $Fail -Force | Out-Null }
    }
  }
}

# -------------------------
# DEBUG: observe 443 remotes (always)
# -------------------------
try {
  $tcp443all = Get-NetTCPConnection -State Established -ErrorAction SilentlyContinue | Where-Object { $_.RemotePort -eq 443 }
  foreach($c in $tcp443all){
    $ProcId=[int]$c.OwningProcess
    if($ProcId -le 4){ continue }

    $p = Get-Process -Id $ProcId -ErrorAction SilentlyContinue
    $img=$null
    if($p -and $p.Path){ $img=[string]$p.Path }

    $rip=[string]$c.RemoteAddress
    if(-not $rip){ continue }

    $prov=$null
    if($dohSet.Count -gt 0 -and $dohSet.ContainsKey($rip)){ $prov=$dohSet[$rip] }

    Write-Audit "tcp443_seen" @{ pid=$ProcId; image=$img; remote=$rip; provider=$prov }
  }
} catch {
  Write-Audit "tcp443_seen_failed" @{ error=$_.Exception.Message }
}

# Optional pause when manual:
#   setx GUARDIANFW_PAUSE 1
if($Host.Name -match "ConsoleHost" -and $env:GUARDIANFW_PAUSE -eq "1"){
  Read-Host "Press Enter" | Out-Null
}

exit 0

} finally {
  if($hasLock){ $mutex.ReleaseMutex() | Out-Null }
  $mutex.Dispose()
}


.ToString("x2") }))
    } finally { $sha.Dispose() }
  }

  # event-specific min gaps
  $minGapSec = switch -Regex ($event) {
    '^tcp443_seen

function HasProp($o,[string]$n){ return ($o -and $o.PSObject.Properties.Match($n).Count -gt 0) }

function Safe-LoadJson([string]$path){
  try { return (Get-Content -LiteralPath $path -Raw -Encoding UTF8 | ConvertFrom-Json) }
  catch { Write-Audit "json_load_failed" @{path=$path; error=$_.Exception.Message}; return $null }
}

# -------------------------
# Load policy
# -------------------------
$cfg = Safe-LoadJson $Policy
if($null -eq $cfg){ exit 0 }

if(-not (HasProp $cfg "process_dns_policy")){
  Write-Audit "process_dns_policy_missing" @{}
  exit 0
}

$pdp = $cfg.process_dns_policy
$mode="monitor"; $action="log"
if(HasProp $pdp "mode"){ $mode=[string]$pdp.mode }
if(HasProp $pdp "action"){ $action=[string]$pdp.action }

$rules=@()
if(HasProp $pdp "allow" -and $pdp.allow){ $rules=@($pdp.allow) }

function Is-AllowedImage([string]$img){
  foreach($r in $rules){
    if($r -and (HasProp $r "image") -and $r.image){
      if($img -ieq [string]$r.image){ return $true }
    }
  }
  return $false
}

# -------------------------
# Load DoH IP list (optional)
# -------------------------
$dohSet = @{}
$doh = Safe-LoadJson $DohIps
if($doh -and (HasProp $doh "providers") -and $doh.providers){
  foreach($prov in @($doh.providers)){
    if($prov -and (HasProp $prov "ips") -and $prov.ips){
      $pname = $null
      if(HasProp $prov "name"){ $pname = [string]$prov.name }
      foreach($ip in @($prov.ips)){
        if($ip){ $dohSet[[string]$ip] = $pname }
      }
    }
  }
}

# -------------------------
# DNS53 detection:
# - UDP: LocalPort == 53
# - TCP: RemotePort == 53
# -------------------------
$udp = Get-NetUDPEndpoint -ErrorAction SilentlyContinue | Where-Object { $_.LocalPort -eq 53 }
foreach($u in $udp){
  $ProcId=[int]$u.OwningProcess
  if($ProcId -le 4){ continue }

  $p = Get-Process -Id $ProcId -ErrorAction SilentlyContinue
  if(!$p -or -not $p.Path){ continue }
  $img=[string]$p.Path

  if(-not (Is-AllowedImage $img)){
    Write-Audit "process_dns_violation" @{
      kind="dns53_udp"; pid=$ProcId; image=$img;
      local=$u.LocalAddress; lport=$u.LocalPort;
      mode=$mode; action=$action
    }

    if($mode -ieq "enforce" -and $action -ieq "kill"){
      try { Stop-Process -Id $ProcId -Force; Write-Audit "process_dns_killed" @{kind="dns53_udp"; pid=$ProcId; image=$img} }
      catch { Write-Audit "process_dns_kill_failed" @{kind="dns53_udp"; pid=$ProcId; image=$img; error=$_.Exception.Message}; New-Item -ItemType File -Path $Fail -Force | Out-Null }
    }
  }
}

$tcp53 = Get-NetTCPConnection -State Established -ErrorAction SilentlyContinue | Where-Object { $_.RemotePort -eq 53 }
foreach($c in $tcp53){
  $ProcId=[int]$c.OwningProcess
  if($ProcId -le 4){ continue }

  $p = Get-Process -Id $ProcId -ErrorAction SilentlyContinue
  if(!$p -or -not $p.Path){ continue }
  $img=[string]$p.Path

  if(-not (Is-AllowedImage $img)){
    Write-Audit "process_dns_violation" @{
      kind="dns53_tcp"; pid=$ProcId; image=$img; remote=$c.RemoteAddress; port=$c.RemotePort;
      mode=$mode; action=$action
    }

    if($mode -ieq "enforce" -and $action -ieq "kill"){
      try { Stop-Process -Id $ProcId -Force; Write-Audit "process_dns_killed" @{kind="dns53_tcp"; pid=$ProcId; image=$img} }
      catch { Write-Audit "process_dns_kill_failed" @{kind="dns53_tcp"; pid=$ProcId; image=$img; error=$_.Exception.Message}; New-Item -ItemType File -Path $Fail -Force | Out-Null }
    }
  }
}

# -------------------------
# DoH IP correlation (SAFE):
# - TCP 443 only if RemoteAddress is in doh-ips.json
# - Include short-lived states to increase capture chance
# -------------------------
if($dohSet.Count -gt 0){
  $tcp443 = Get-NetTCPConnection -ErrorAction SilentlyContinue |
            Where-Object { $_.RemotePort -eq 443 -and $_.State -in @("Established","SynSent","TimeWait") }

  foreach($c in $tcp443){
    $rip = [string]$c.RemoteAddress
    if(-not $rip){ continue }
    if(-not $dohSet.ContainsKey($rip)){ continue }

    $ProcId=[int]$c.OwningProcess
    if($ProcId -le 4){ continue }

    $p = Get-Process -Id $ProcId -ErrorAction SilentlyContinue
    $img = $null
    if($p -and $p.Path){ $img = [string]$p.Path }

    $provider = $dohSet[$rip]

    Write-Audit "process_dns_violation" @{
      kind="doh_ip_hit"; pid=$ProcId; image=$img; remote=$rip; port=443; provider=$provider;
      mode=$mode; action=$action
    }

    if($Host.Name -match "ConsoleHost"){
      Write-Host ("DoH hit: {0} {1} {2}" -f $provider, $rip, $img)
    }

    if($mode -ieq "enforce" -and $action -ieq "kill"){
      try { Stop-Process -Id $ProcId -Force; Write-Audit "process_dns_killed" @{kind="doh_ip_hit"; pid=$ProcId; image=$img; remote=$rip; provider=$provider} }
      catch { Write-Audit "process_dns_kill_failed" @{kind="doh_ip_hit"; pid=$ProcId; image=$img; remote=$rip; provider=$provider; error=$_.Exception.Message}; New-Item -ItemType File -Path $Fail -Force | Out-Null }
    }
  }
}

# -------------------------
# DEBUG: observe 443 remotes (always)
# -------------------------
try {
  $tcp443all = Get-NetTCPConnection -State Established -ErrorAction SilentlyContinue | Where-Object { $_.RemotePort -eq 443 }
  foreach($c in $tcp443all){
    $ProcId=[int]$c.OwningProcess
    if($ProcId -le 4){ continue }

    $p = Get-Process -Id $ProcId -ErrorAction SilentlyContinue
    $img=$null
    if($p -and $p.Path){ $img=[string]$p.Path }

    $rip=[string]$c.RemoteAddress
    if(-not $rip){ continue }

    $prov=$null
    if($dohSet.Count -gt 0 -and $dohSet.ContainsKey($rip)){ $prov=$dohSet[$rip] }

    Write-Audit "tcp443_seen" @{ pid=$ProcId; image=$img; remote=$rip; provider=$prov }
  }
} catch {
  Write-Audit "tcp443_seen_failed" @{ error=$_.Exception.Message }
}

# Optional pause when manual:
#   setx GUARDIANFW_PAUSE 1
if($Host.Name -match "ConsoleHost" -and $env:GUARDIANFW_PAUSE -eq "1"){
  Read-Host "Press Enter" | Out-Null
}

exit 0

} finally {
  if($hasLock){ $mutex.ReleaseMutex() | Out-Null }
  $mutex.Dispose()
}


      { 300 }   # 5 min per (pid+remote+image)
    '^lolbin_detected

function HasProp($o,[string]$n){ return ($o -and $o.PSObject.Properties.Match($n).Count -gt 0) }

function Safe-LoadJson([string]$path){
  try { return (Get-Content -LiteralPath $path -Raw -Encoding UTF8 | ConvertFrom-Json) }
  catch { Write-Audit "json_load_failed" @{path=$path; error=$_.Exception.Message}; return $null }
}

# -------------------------
# Load policy
# -------------------------
$cfg = Safe-LoadJson $Policy
if($null -eq $cfg){ exit 0 }

if(-not (HasProp $cfg "process_dns_policy")){
  Write-Audit "process_dns_policy_missing" @{}
  exit 0
}

$pdp = $cfg.process_dns_policy
$mode="monitor"; $action="log"
if(HasProp $pdp "mode"){ $mode=[string]$pdp.mode }
if(HasProp $pdp "action"){ $action=[string]$pdp.action }

$rules=@()
if(HasProp $pdp "allow" -and $pdp.allow){ $rules=@($pdp.allow) }

function Is-AllowedImage([string]$img){
  foreach($r in $rules){
    if($r -and (HasProp $r "image") -and $r.image){
      if($img -ieq [string]$r.image){ return $true }
    }
  }
  return $false
}

# -------------------------
# Load DoH IP list (optional)
# -------------------------
$dohSet = @{}
$doh = Safe-LoadJson $DohIps
if($doh -and (HasProp $doh "providers") -and $doh.providers){
  foreach($prov in @($doh.providers)){
    if($prov -and (HasProp $prov "ips") -and $prov.ips){
      $pname = $null
      if(HasProp $prov "name"){ $pname = [string]$prov.name }
      foreach($ip in @($prov.ips)){
        if($ip){ $dohSet[[string]$ip] = $pname }
      }
    }
  }
}

# -------------------------
# DNS53 detection:
# - UDP: LocalPort == 53
# - TCP: RemotePort == 53
# -------------------------
$udp = Get-NetUDPEndpoint -ErrorAction SilentlyContinue | Where-Object { $_.LocalPort -eq 53 }
foreach($u in $udp){
  $ProcId=[int]$u.OwningProcess
  if($ProcId -le 4){ continue }

  $p = Get-Process -Id $ProcId -ErrorAction SilentlyContinue
  if(!$p -or -not $p.Path){ continue }
  $img=[string]$p.Path

  if(-not (Is-AllowedImage $img)){
    Write-Audit "process_dns_violation" @{
      kind="dns53_udp"; pid=$ProcId; image=$img;
      local=$u.LocalAddress; lport=$u.LocalPort;
      mode=$mode; action=$action
    }

    if($mode -ieq "enforce" -and $action -ieq "kill"){
      try { Stop-Process -Id $ProcId -Force; Write-Audit "process_dns_killed" @{kind="dns53_udp"; pid=$ProcId; image=$img} }
      catch { Write-Audit "process_dns_kill_failed" @{kind="dns53_udp"; pid=$ProcId; image=$img; error=$_.Exception.Message}; New-Item -ItemType File -Path $Fail -Force | Out-Null }
    }
  }
}

$tcp53 = Get-NetTCPConnection -State Established -ErrorAction SilentlyContinue | Where-Object { $_.RemotePort -eq 53 }
foreach($c in $tcp53){
  $ProcId=[int]$c.OwningProcess
  if($ProcId -le 4){ continue }

  $p = Get-Process -Id $ProcId -ErrorAction SilentlyContinue
  if(!$p -or -not $p.Path){ continue }
  $img=[string]$p.Path

  if(-not (Is-AllowedImage $img)){
    Write-Audit "process_dns_violation" @{
      kind="dns53_tcp"; pid=$ProcId; image=$img; remote=$c.RemoteAddress; port=$c.RemotePort;
      mode=$mode; action=$action
    }

    if($mode -ieq "enforce" -and $action -ieq "kill"){
      try { Stop-Process -Id $ProcId -Force; Write-Audit "process_dns_killed" @{kind="dns53_tcp"; pid=$ProcId; image=$img} }
      catch { Write-Audit "process_dns_kill_failed" @{kind="dns53_tcp"; pid=$ProcId; image=$img; error=$_.Exception.Message}; New-Item -ItemType File -Path $Fail -Force | Out-Null }
    }
  }
}

# -------------------------
# DoH IP correlation (SAFE):
# - TCP 443 only if RemoteAddress is in doh-ips.json
# - Include short-lived states to increase capture chance
# -------------------------
if($dohSet.Count -gt 0){
  $tcp443 = Get-NetTCPConnection -ErrorAction SilentlyContinue |
            Where-Object { $_.RemotePort -eq 443 -and $_.State -in @("Established","SynSent","TimeWait") }

  foreach($c in $tcp443){
    $rip = [string]$c.RemoteAddress
    if(-not $rip){ continue }
    if(-not $dohSet.ContainsKey($rip)){ continue }

    $ProcId=[int]$c.OwningProcess
    if($ProcId -le 4){ continue }

    $p = Get-Process -Id $ProcId -ErrorAction SilentlyContinue
    $img = $null
    if($p -and $p.Path){ $img = [string]$p.Path }

    $provider = $dohSet[$rip]

    Write-Audit "process_dns_violation" @{
      kind="doh_ip_hit"; pid=$ProcId; image=$img; remote=$rip; port=443; provider=$provider;
      mode=$mode; action=$action
    }

    if($Host.Name -match "ConsoleHost"){
      Write-Host ("DoH hit: {0} {1} {2}" -f $provider, $rip, $img)
    }

    if($mode -ieq "enforce" -and $action -ieq "kill"){
      try { Stop-Process -Id $ProcId -Force; Write-Audit "process_dns_killed" @{kind="doh_ip_hit"; pid=$ProcId; image=$img; remote=$rip; provider=$provider} }
      catch { Write-Audit "process_dns_kill_failed" @{kind="doh_ip_hit"; pid=$ProcId; image=$img; remote=$rip; provider=$provider; error=$_.Exception.Message}; New-Item -ItemType File -Path $Fail -Force | Out-Null }
    }
  }
}

# -------------------------
# DEBUG: observe 443 remotes (always)
# -------------------------
try {
  $tcp443all = Get-NetTCPConnection -State Established -ErrorAction SilentlyContinue | Where-Object { $_.RemotePort -eq 443 }
  foreach($c in $tcp443all){
    $ProcId=[int]$c.OwningProcess
    if($ProcId -le 4){ continue }

    $p = Get-Process -Id $ProcId -ErrorAction SilentlyContinue
    $img=$null
    if($p -and $p.Path){ $img=[string]$p.Path }

    $rip=[string]$c.RemoteAddress
    if(-not $rip){ continue }

    $prov=$null
    if($dohSet.Count -gt 0 -and $dohSet.ContainsKey($rip)){ $prov=$dohSet[$rip] }

    Write-Audit "tcp443_seen" @{ pid=$ProcId; image=$img; remote=$rip; provider=$prov }
  }
} catch {
  Write-Audit "tcp443_seen_failed" @{ error=$_.Exception.Message }
}

# Optional pause when manual:
#   setx GUARDIANFW_PAUSE 1
if($Host.Name -match "ConsoleHost" -and $env:GUARDIANFW_PAUSE -eq "1"){
  Read-Host "Press Enter" | Out-Null
}

exit 0

} finally {
  if($hasLock){ $mutex.ReleaseMutex() | Out-Null }
  $mutex.Dispose()
}


  { 3600 }  # 60 min per (eventId+ScriptBlockId)
    default              { 300 }   # 5 min for other noisy classes
  }

  $key = Get-StableKey $event $data
  $now = [DateTime]::UtcNow

  # load state (json -> hashtable)
  $state = @{}
  if(Test-Path $stateFile){
    try{
      $obj = Get-Content $stateFile -Raw -Encoding UTF8 | ConvertFrom-Json
      if($obj){
        foreach($prop in $obj.PSObject.Properties){
          $state[$prop.Name] = [string]$prop.Value
        }
      }
    } catch { $state = @{} }
  }

  # prune old keys (>2 days)
  foreach($k in @($state.Keys)){
    try{
      $t = [DateTime]::Parse($state[$k]).ToUniversalTime()
      if(($now - $t).TotalDays -gt 2){ $state.Remove($k) }
    } catch { $state.Remove($k) }
  }

  # suppress duplicates
  if($null -ne $key -and $state.ContainsKey($key)){
    $last = $null
    try { $last = [DateTime]::Parse($state[$key]).ToUniversalTime() } catch { $last = $null }
    if($null -ne $last -and ($now - $last).TotalSeconds -lt $minGapSec){
      return
    }
  }

  # write audit record
  $rec=[pscustomobject]@{
    tsUtc = (Get-Date).ToUniversalTime().ToString("o")
    event = $event
    data  = $data
  }
  ($rec|ConvertTo-Json -Compress -Depth 12) | Add-Content -LiteralPath $Audit -Encoding UTF8

  # update state
  if($null -ne $key){
    $state[$key] = $now.ToString("o")
    try { ($state | ConvertTo-Json -Depth 6) | Set-Content -LiteralPath $stateFile -Encoding UTF8 } catch { }
  }
}

function HasProp($o,[string]$n){ return ($o -and $o.PSObject.Properties.Match($n).Count -gt 0) }

function Safe-LoadJson([string]$path){
  try { return (Get-Content -LiteralPath $path -Raw -Encoding UTF8 | ConvertFrom-Json) }
  catch { Write-Audit "json_load_failed" @{path=$path; error=$_.Exception.Message}; return $null }
}

# -------------------------
# Load policy
# -------------------------
$cfg = Safe-LoadJson $Policy
if($null -eq $cfg){ exit 0 }

if(-not (HasProp $cfg "process_dns_policy")){
  Write-Audit "process_dns_policy_missing" @{}
  exit 0
}

$pdp = $cfg.process_dns_policy
$mode="monitor"; $action="log"
if(HasProp $pdp "mode"){ $mode=[string]$pdp.mode }
if(HasProp $pdp "action"){ $action=[string]$pdp.action }

$rules=@()
if(HasProp $pdp "allow" -and $pdp.allow){ $rules=@($pdp.allow) }

function Is-AllowedImage([string]$img){
  foreach($r in $rules){
    if($r -and (HasProp $r "image") -and $r.image){
      if($img -ieq [string]$r.image){ return $true }
    }
  }
  return $false
}

# -------------------------
# Load DoH IP list (optional)
# -------------------------
$dohSet = @{}
$doh = Safe-LoadJson $DohIps
if($doh -and (HasProp $doh "providers") -and $doh.providers){
  foreach($prov in @($doh.providers)){
    if($prov -and (HasProp $prov "ips") -and $prov.ips){
      $pname = $null
      if(HasProp $prov "name"){ $pname = [string]$prov.name }
      foreach($ip in @($prov.ips)){
        if($ip){ $dohSet[[string]$ip] = $pname }
      }
    }
  }
}

# -------------------------
# DNS53 detection:
# - UDP: LocalPort == 53
# - TCP: RemotePort == 53
# -------------------------
$udp = Get-NetUDPEndpoint -ErrorAction SilentlyContinue | Where-Object { $_.LocalPort -eq 53 }
foreach($u in $udp){
  $ProcId=[int]$u.OwningProcess
  if($ProcId -le 4){ continue }

  $p = Get-Process -Id $ProcId -ErrorAction SilentlyContinue
  if(!$p -or -not $p.Path){ continue }
  $img=[string]$p.Path

  if(-not (Is-AllowedImage $img)){
    Write-Audit "process_dns_violation" @{
      kind="dns53_udp"; pid=$ProcId; image=$img;
      local=$u.LocalAddress; lport=$u.LocalPort;
      mode=$mode; action=$action
    }

    if($mode -ieq "enforce" -and $action -ieq "kill"){
      try { Stop-Process -Id $ProcId -Force; Write-Audit "process_dns_killed" @{kind="dns53_udp"; pid=$ProcId; image=$img} }
      catch { Write-Audit "process_dns_kill_failed" @{kind="dns53_udp"; pid=$ProcId; image=$img; error=$_.Exception.Message}; New-Item -ItemType File -Path $Fail -Force | Out-Null }
    }
  }
}

$tcp53 = Get-NetTCPConnection -State Established -ErrorAction SilentlyContinue | Where-Object { $_.RemotePort -eq 53 }
foreach($c in $tcp53){
  $ProcId=[int]$c.OwningProcess
  if($ProcId -le 4){ continue }

  $p = Get-Process -Id $ProcId -ErrorAction SilentlyContinue
  if(!$p -or -not $p.Path){ continue }
  $img=[string]$p.Path

  if(-not (Is-AllowedImage $img)){
    Write-Audit "process_dns_violation" @{
      kind="dns53_tcp"; pid=$ProcId; image=$img; remote=$c.RemoteAddress; port=$c.RemotePort;
      mode=$mode; action=$action
    }

    if($mode -ieq "enforce" -and $action -ieq "kill"){
      try { Stop-Process -Id $ProcId -Force; Write-Audit "process_dns_killed" @{kind="dns53_tcp"; pid=$ProcId; image=$img} }
      catch { Write-Audit "process_dns_kill_failed" @{kind="dns53_tcp"; pid=$ProcId; image=$img; error=$_.Exception.Message}; New-Item -ItemType File -Path $Fail -Force | Out-Null }
    }
  }
}

# -------------------------
# DoH IP correlation (SAFE):
# - TCP 443 only if RemoteAddress is in doh-ips.json
# - Include short-lived states to increase capture chance
# -------------------------
if($dohSet.Count -gt 0){
  $tcp443 = Get-NetTCPConnection -ErrorAction SilentlyContinue |
            Where-Object { $_.RemotePort -eq 443 -and $_.State -in @("Established","SynSent","TimeWait") }

  foreach($c in $tcp443){
    $rip = [string]$c.RemoteAddress
    if(-not $rip){ continue }
    if(-not $dohSet.ContainsKey($rip)){ continue }

    $ProcId=[int]$c.OwningProcess
    if($ProcId -le 4){ continue }

    $p = Get-Process -Id $ProcId -ErrorAction SilentlyContinue
    $img = $null
    if($p -and $p.Path){ $img = [string]$p.Path }

    $provider = $dohSet[$rip]

    Write-Audit "process_dns_violation" @{
      kind="doh_ip_hit"; pid=$ProcId; image=$img; remote=$rip; port=443; provider=$provider;
      mode=$mode; action=$action
    }

    if($Host.Name -match "ConsoleHost"){
      Write-Host ("DoH hit: {0} {1} {2}" -f $provider, $rip, $img)
    }

    if($mode -ieq "enforce" -and $action -ieq "kill"){
      try { Stop-Process -Id $ProcId -Force; Write-Audit "process_dns_killed" @{kind="doh_ip_hit"; pid=$ProcId; image=$img; remote=$rip; provider=$provider} }
      catch { Write-Audit "process_dns_kill_failed" @{kind="doh_ip_hit"; pid=$ProcId; image=$img; remote=$rip; provider=$provider; error=$_.Exception.Message}; New-Item -ItemType File -Path $Fail -Force | Out-Null }
    }
  }
}

# -------------------------
# DEBUG: observe 443 remotes (always)
# -------------------------
try {
  $tcp443all = Get-NetTCPConnection -State Established -ErrorAction SilentlyContinue | Where-Object { $_.RemotePort -eq 443 }
  foreach($c in $tcp443all){
    $ProcId=[int]$c.OwningProcess
    if($ProcId -le 4){ continue }

    $p = Get-Process -Id $ProcId -ErrorAction SilentlyContinue
    $img=$null
    if($p -and $p.Path){ $img=[string]$p.Path }

    $rip=[string]$c.RemoteAddress
    if(-not $rip){ continue }

    $prov=$null
    if($dohSet.Count -gt 0 -and $dohSet.ContainsKey($rip)){ $prov=$dohSet[$rip] }

    Write-Audit "tcp443_seen" @{ pid=$ProcId; image=$img; remote=$rip; provider=$prov }
  }
} catch {
  Write-Audit "tcp443_seen_failed" @{ error=$_.Exception.Message }
}

# Optional pause when manual:
#   setx GUARDIANFW_PAUSE 1
if($Host.Name -match "ConsoleHost" -and $env:GUARDIANFW_PAUSE -eq "1"){
  Read-Host "Press Enter" | Out-Null
}

exit 0

} finally {
  if($hasLock){ $mutex.ReleaseMutex() | Out-Null }
  $mutex.Dispose()
}









