# --- Single-instance guard (mutex) ---
$mutexName = "Global\GuardianFW-ProcessDNS"
$mutex = New-Object System.Threading.Mutex($false, $mutexName)
$hasLock = $false
try {
  $hasLock = $mutex.WaitOne(0)
  if(-not $hasLock){ exit 0 }

Set-StrictMode -Version Latest
$ErrorActionPreference="Stop"

$Root="C:\ProgramData\GuardianFW"
$Policy=Join-Path $Root "policy\policy.json"
$DohIps=Join-Path $Root "policy\doh-ips.json"
$Audit=Join-Path $Root "logs\guardian-audit.jsonl"
# ---- TCP443_SIMPLE_TTL_STATE ----
if(-not $script:Tcp443LastSeen){ $script:Tcp443LastSeen = @{} }
$script:Tcp443TtlSeconds = 60

$Fail =Join-Path $Root "sealed\FAIL_SECURE.flag"

function Write-Audit([string]$event,[hashtable]$data=@{}) {
  $dir = Split-Path $Audit
  if(!(Test-Path $dir)){ New-Item -ItemType Directory -Path $dir -Force | Out-Null }
    # ---- Compact huge events ----
  if($event -eq "lolbin_detected" -and $data -is [hashtable] -and $data.ContainsKey("message")){
    $m = [string]$data["message"]
    if($m.Length -gt 600){ $data["message"] = $m.Substring(0,600) + "...(truncated)" }
  }
$rec=[pscustomobject]@{ tsUtc=(Get-Date).ToUniversalTime().ToString("o"); event=$event; data=$data }
  ($rec|ConvertTo-Json -Compress -Depth 12) | Add-Content -LiteralPath $Audit -Encoding UTF8
}

function HasProp($o,[string]$n){ return ($o -and $o.PSObject.Properties.Match($n).Count -gt 0) }

function Safe-LoadJson([string]$path){
  try { return (Get-Content -LiteralPath $path -Raw -Encoding UTF8 | ConvertFrom-Json) }
  catch { Write-Audit "json_load_failed" @{path=$path; error=$_.Exception.Message}; return $null }
}

# -------------------------
# Load policy
# -------------------------
$cfg = Safe-LoadJson $Policy
if($null -eq $cfg){ exit 0 }

if(-not (HasProp $cfg "process_dns_policy")){
  Write-Audit "process_dns_policy_missing" @{}
  exit 0
}

$pdp = $cfg.process_dns_policy
$mode="monitor"; $action="log"
if(HasProp $pdp "mode"){ $mode=[string]$pdp.mode }
if(HasProp $pdp "action"){ $action=[string]$pdp.action }

$rules=@()
if(HasProp $pdp "allow" -and $pdp.allow){ $rules=@($pdp.allow) }

function Is-AllowedImage([string]$img){
  foreach($r in $rules){
    if($r -and (HasProp $r "image") -and $r.image){
      if($img -ieq [string]$r.image){ return $true }
    }
  }
  return $false
}

# -------------------------
# Load DoH IP list (optional)
# -------------------------
$dohSet = @{}
$doh = Safe-LoadJson $DohIps
if($doh -and (HasProp $doh "providers") -and $doh.providers){
  foreach($prov in @($doh.providers)){
    if($prov -and (HasProp $prov "ips") -and $prov.ips){
      $pname = $null
      if(HasProp $prov "name"){ $pname = [string]$prov.name }
      foreach($ip in @($prov.ips)){
        if($ip){ $dohSet[[string]$ip] = $pname }
      }
    }
  }
}

# -------------------------
# DNS53 detection:
# - UDP: LocalPort == 53
# - TCP: RemotePort == 53
# -------------------------
$udp = Get-NetUDPEndpoint -ErrorAction SilentlyContinue | Where-Object { $_.LocalPort -eq 53 }
foreach($u in $udp){
  $ProcId=[int]$u.OwningProcess
  if($ProcId -le 4){ continue }

  $p = Get-Process -Id $ProcId -ErrorAction SilentlyContinue
  if(!$p -or -not $p.Path){ continue }
  $img=[string]$p.Path

  if(-not (Is-AllowedImage $img)){
    Write-Audit "process_dns_violation" @{
      kind="dns53_udp"; pid=$ProcId; image=$img;
      local=$u.LocalAddress; lport=$u.LocalPort;
      mode=$mode; action=$action
    }

    if($mode -ieq "enforce" -and $action -ieq "kill"){
      try { Stop-Process -Id $ProcId -Force; Write-Audit "process_dns_killed" @{kind="dns53_udp"; pid=$ProcId; image=$img} }
      catch { Write-Audit "process_dns_kill_failed" @{kind="dns53_udp"; pid=$ProcId; image=$img; error=$_.Exception.Message}; New-Item -ItemType File -Path $Fail -Force | Out-Null }
    }
  }
}

$tcp53 = Get-NetTCPConnection -State Established -ErrorAction SilentlyContinue | Where-Object { $_.RemotePort -eq 53 }
foreach($c in $tcp53){
  $ProcId=[int]$c.OwningProcess
  if($ProcId -le 4){ continue }

  $p = Get-Process -Id $ProcId -ErrorAction SilentlyContinue
  if(!$p -or -not $p.Path){ continue }
  $img=[string]$p.Path

  if(-not (Is-AllowedImage $img)){
    Write-Audit "process_dns_violation" @{
      kind="dns53_tcp"; pid=$ProcId; image=$img; remote=$c.RemoteAddress; port=$c.RemotePort;
      mode=$mode; action=$action
    }

    if($mode -ieq "enforce" -and $action -ieq "kill"){
      try { Stop-Process -Id $ProcId -Force; Write-Audit "process_dns_killed" @{kind="dns53_tcp"; pid=$ProcId; image=$img} }
      catch { Write-Audit "process_dns_kill_failed" @{kind="dns53_tcp"; pid=$ProcId; image=$img; error=$_.Exception.Message}; New-Item -ItemType File -Path $Fail -Force | Out-Null }
    }
  }
}

# -------------------------
# DoH IP correlation (SAFE):
# - TCP 443 only if RemoteAddress is in doh-ips.json
# - Include short-lived states to increase capture chance
# -------------------------
if($dohSet.Count -gt 0){
  $tcp443 = Get-NetTCPConnection -ErrorAction SilentlyContinue |
            Where-Object { $_.RemotePort -eq 443 -and $_.State -in @("Established","SynSent","TimeWait") }

  foreach($c in $tcp443){
    $rip = [string]$c.RemoteAddress
    if(-not $rip){ continue }
    if(-not $dohSet.ContainsKey($rip)){ continue }

    $ProcId=[int]$c.OwningProcess
    if($ProcId -le 4){ continue }

    $p = Get-Process -Id $ProcId -ErrorAction SilentlyContinue
    $img = $null
    if($p -and $p.Path){ $img = [string]$p.Path }

    $provider = $dohSet[$rip]

    Write-Audit "process_dns_violation" @{
      kind="doh_ip_hit"; pid=$ProcId; image=$img; remote=$rip; port=443; provider=$provider;
      mode=$mode; action=$action
    }

    if($Host.Name -match "ConsoleHost"){
      Write-Host ("DoH hit: {0} {1} {2}" -f $provider, $rip, $img)
    }

    if($mode -ieq "enforce" -and $action -ieq "kill"){
      try { Stop-Process -Id $ProcId -Force; Write-Audit "process_dns_killed" @{kind="doh_ip_hit"; pid=$ProcId; image=$img; remote=$rip; provider=$provider} }
      catch { Write-Audit "process_dns_kill_failed" @{kind="doh_ip_hit"; pid=$ProcId; image=$img; remote=$rip; provider=$provider; error=$_.Exception.Message}; New-Item -ItemType File -Path $Fail -Force | Out-Null }
    }
  }
}

# -------------------------
# DEBUG: observe 443 remotes (always)
# -------------------------
try {
  $tcp443all = Get-NetTCPConnection -State Established -ErrorAction SilentlyContinue | Where-Object { $_.RemotePort -eq 443 }
  foreach($c in $tcp443all){
    $ProcId=[int]$c.OwningProcess
    if($ProcId -le 4){ continue }

    $p = Get-Process -Id $ProcId -ErrorAction SilentlyContinue
    $img=$null
    if($p -and $p.Path){ $img=[string]$p.Path }

    $rip=[string]$c.RemoteAddress
    if(-not $rip){ continue }

    $prov=$null
    if($dohSet.Count -gt 0 -and $dohSet.ContainsKey($rip)){ $prov=$dohSet[$rip] }

# ---- TCP443_SIMPLE_TTL_GATE ----
try{
  # File-backed TTL throttle (works across processes/reboots)
  $rootState = "C:\ProgramData\GuardianFW\state"
  if(!(Test-Path -LiteralPath $rootState)){ New-Item -ItemType Directory -Path $rootState -Force | Out-Null }
  $stateFile = Join-Path $rootState "tcp443-simplettl.json"

  # Key on PID+image only (do NOT include remote/provider)
  $key = ("{0}|{1}" -f $ProcId, $img)
  $now = [DateTime]::UtcNow

  $mtx = New-Object System.Threading.Mutex($false,"Global\GuardianFW_Tcp443SimpleTtl")
  try {
    if(-not $mtx.WaitOne(5000)){ }  # fail-open: if mutex busy, allow logging

    $map=@{}
    if(Test-Path -LiteralPath $stateFile){
      try { $map = (Get-Content -LiteralPath $stateFile -Raw -Encoding UTF8 | ConvertFrom-Json -EA Stop) } catch { $map=@{} }
    }
    if(-not ($map -is [hashtable])){
      # ConvertFrom-Json returns PSCustomObject sometimes; normalize
      $h=@{}
      if($map){ foreach($p in $map.PSObject.Properties){ $h[$p.Name] = $p.Value } }
      $map = $h
    }

    if($map.ContainsKey($key)){
      try {
        $last = [DateTime]::Parse([string]$map[$key])
        if(($now-$last).TotalSeconds -lt $script:Tcp443TtlSeconds){
          return
        }
      } catch { }
    }

    $map[$key] = $now.ToString("o")
    try {
      $tmp = "$stateFile.tmp"
      ($map | ConvertTo-Json -Depth 4) | Set-Content -LiteralPath $tmp -Encoding UTF8 -Force
      Move-Item -LiteralPath $tmp -Destination $stateFile -Force
    } catch { }
  } finally {
    try { $mtx.ReleaseMutex() } catch {}
    $mtx.Dispose()
  }
} catch {
  # fail-open: do not block logging on errors
}

    Write-Audit "tcp443_seen" @{ pid=$ProcId; image=$img; remote=$rip; provider=$prov }
  }
} catch {
  Write-Audit "tcp443_seen_failed" @{ error=$_.Exception.Message }
}

# Optional pause when manual:
#   setx GUARDIANFW_PAUSE 1
if($Host.Name -match "ConsoleHost" -and $env:GUARDIANFW_PAUSE -eq "1"){
  Read-Host "Press Enter" | Out-Null
}

exit 0

} finally {
  if($hasLock){ $mutex.ReleaseMutex() | Out-Null }
  $mutex.Dispose()
}


